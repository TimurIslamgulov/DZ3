## Основные команды Git ##

*Введение в контроль версий. Работа с Git. Составление инструкции по работе с Git.*

## git init – инициализация локального репозитория

## git status – получить информацию от git о его текущем состоянии

## git add – добавить файл или файлы к следующему коммиту

# git commit -m “message” – создание коммита.

## git log – вывод на экран истории всех коммитов с их хеш-кодами.
--graph Добавить визуализацию веток.

## git checkout – переход от одного коммита к другому

## git checkout master – вернуться к актуальному состоянию и продолжить работу

##  git diff – увидеть разницу между текущим файлом и закоммиченным файлом

## git --global user.name "__" – один раз нужно представиться и ввести почту.

## file -- avtosave  полезно включить автосохранение.

## git branch выводит информацию от ветках изменеий. если ввести название, то создается новая ветка. 
для удалениия git branch -d master , где мастер это название ветки, котрую надо удалить

## git pull извлекать из другого репозитория или локальной ветки и интегрировать с ней
### КРАТКИЙ ОБЗОР
git pull [<параметры>] [<репозиторий> [<спецификация ссылки>...]]
### Описание
Включает изменения из удаленного репозитория в текущую ветку. Если текущая ветка находится за удаленным, то по умолчанию выполняется быстрая перемотка текущей ветки, чтобы она соответствовала удаленной. Если текущая ветвь и удаленный сервер разошлись, пользователю необходимо указать, как согласовать расходящиеся ветви с помощью --rebase или --no-rebase (или соответствующего параметра конфигурации в pull.rebase).

Более точно, git pull запускается git fetch с заданными параметрами, а затем, в зависимости от параметров конфигурации или флагов командной строки, вызывает либо git rebase, либо git merge для согласования расходящихся ветвей.

<https://git-scm.com/docs/git-pull>


## git push выкачать на github (Обновление удаленных ссылок вместе со связанными объектами)
git push [--все | -- ветви | --зеркало | --теги] [--теги следования] [--атомарный] [-n | --предварительный запуск] [--receive-pack=<git-receive-pack>]
 [--repo=<репозиторий>] [-f | --force] [-d | --delete] [-prune] [-v | --подробный]
 [-u | --set-upstream] [-o <строка> | --push-option=<строка>]
 [--[нет-]подписано|--signed=(истина|ложь|позапросу)]
 [--принудительно использовать с арендой[=<имя_ ссылки>[:<ожидать>]] [--принудительно использовать,есливключает]]
 [--no-verify] [<репозиторий> [<Спецификация ссылки>...]]
### Описание
Обновляет удаленные ссылки, используя локальные ссылки, одновременно отправляя объекты, необходимые для завершения заданных ссылок.
#### ПРИМЕРЫ
git push
Работает аналогично git push <remote>, где <remote> - это удаленный доступ к текущей ветке (или origin, если для текущей ветки не настроен ни один удаленный доступ).

git push origin
Без дополнительной настройки отправляет текущую ветвь в настроенный восходящий поток (branch.<name>.merge переменная конфигурации), если она имеет то же имя, что и текущая ветвь, и выдает ошибку без нажатия в противном случае.

## git-clone - клонировать репозиторий в новый каталог

### git clone [--template=<каталог шаблонов>]
 [-l] [-s] [--без жестких ссылок] [-q] [-n] [--голый] [--зеркало]
 [-o <имя>] [-b <имя>] [-u <upload-pack>] [--ссылка <репозиторий>]
 [--dissociate] [--separate-git-dir <git-dir>]
 [--depth <глубина>] [--[без] одиночной ветви] [--безтегов]
 [--recurse-submodules[=<pathspec>]] [--[без] мелких подмодулей]
 [--[нет-] удаленных подмодулей] [--заданий <n>] [--разреженный] [--[нет-] отклоненный-мелкий]
 [--filter=<фильтр> [--также-filter-submodules]] [--] <репозиторий>
 [<каталог>]
#### Описание
Клонирует репозиторий во вновь созданный каталог, создает ветви удаленного отслеживания для каждой ветви в клонированном репозитории (видимые с помощью git branch --remotes), а также создает и проверяет начальную ветвь, которая разветвляется на текущую активную ветвь клонированного репозитория.

# git rm --cached Screenshot_2.png  Удаляет фалйл из комита.

    -n                    do not show a diffstat at the end of the merge
    --stat                show a diffstat at the end of the merge
    --summary             (synonym to --stat)
    --log[=<n>]           add (at most <n>) entries from shortlog to merge commit message
    --squash              create a single commit instead of doing a merge
    --commit              perform a commit if the merge succeeds (default)
    -e, --edit            edit message before committing
    --cleanup <mode>      how to strip spaces and #comments from message
    --ff                  allow fast-forward (default)
    --ff-only             abort if fast-forward is not possible
    --rerere-autoupdate   update the index with reused conflict resolution if possible
    --verify-signatures   verify that the named commit has a valid GPG signature
    -s, --strategy <strategy>
                          merge strategy to use
    -X, --strategy-option <option=value>
                          option for selected merge strategy
    -m, --message <message>
                          merge commit message (for a non-fast-forward merge)
    -F, --file <path>     read message from file
    --into-name <name>    use <name> instead of the real target
    -v, --verbose         be more verbose
    -q, --quiet           be more quiet
    --abort               abort the current in-progress merge
    --quit                --abort but leave index and working tree alone
    --continue            continue the current in-progress merge
    --allow-unrelated-histories
                          allow merging unrelated histories
    --progress            force progress reporting
    -S, --gpg-sign[=<key-id>]
                          GPG sign commit
    --autostash           automatically stash/stash pop before and after
    --overwrite-ignore    update ignored files (default)
    --signoff             add a Signed-off-by trailer
    --no-verify           bypass pre-merge-commit and commit-msg hooks

   
## cherry-pick

git cherry-pick [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]
 [-S[<keyid>]] <commit>…​
git cherry-pick (--continue | --skip | --abort | --quit)

Учитывая один или несколько существующих коммитов, примените изменения, вносимые каждым из них, записывая новый коммит для каждого. Для этого ваше рабочее дерево должно быть чистым (никаких изменений из головного коммита).

Когда не очевидно, как применить изменение, происходит следующее:

Текущая ветвь и HEAD указатель остаются на последней успешно выполненной фиксации.

CHERRY_PICK_HEADСсылка устанавливается так, чтобы указывать на фиксацию, которая внесла изменение, которое трудно применить.

Пути, в которых изменения были применены чисто, обновляются как в индексном файле, так и в вашем рабочем дереве.

Для конфликтующих путей индексный файл записывает до трех версий, как описано в разделе "ИСТИННОЕ СЛИЯНИЕ" git-merge[1]. Файлы рабочего дерева будут включать описание конфликта, заключенное в квадратные скобки обычными маркерами конфликта <<<<<<< и >>>>>>>.

Никаких других изменений не внесено.**

Смотрите git-merge[1] некоторые подсказки по разрешению таких конфликтов приведены в разделе.

https://git-scm.com/docs/git-cherry-pick

## git-merge слияние веток

## reset git-reset - сброс текущего HEAD в указанное состояние

git reset [-q] [<tree-ish>] [--] <pathspec>…​
git reset [-q] [--pat hspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>…​]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]

Вы с удовольствием работаете над чем-то и обнаруживаете, что изменения в этих файлах в полном порядке. Вы не хотите видеть их при запуске git diff, потому что вы планируете работать с другими файлами, а изменения с этими файлами отвлекают.

Кто-то просит вас вытащить, и изменения кажутся достойными объединения.

Однако вы уже испортили индекс (т. Е. ваш индекс не соответствует HEAD фиксации). Но вы знаете, что удаление, которое вы собираетесь выполнить, не влияет на frotz.c или filfre.c, поэтому вы отменяете изменения индекса для этих двух файлов. Ваши изменения в рабочем дереве остаются там.

Затем вы можете вытащить и объединить, оставив frotz.c и filfre.c изменения по-прежнему в рабочем дереве.



##  revert git-revert - отменить некоторые существующие коммиты
### Описание

Учитывая один или несколько существующих коммитов, отмените изменения, внесенные соответствующими исправлениями, и запишите несколько новых коммитов, которые их фиксируют. Для этого ваше рабочее дерево должно быть чистым (никаких изменений из головного коммита).

Примечание: git revert используется для записи некоторых новых коммитов, чтобы отменить действие некоторых предыдущих коммитов (часто только ошибочных). Если вы хотите удалить все незафиксированные изменения в вашем рабочем каталоге, вы должны увидеть git-reset[1], в частности, --hard опцию. Если вы хотите извлечь определенные файлы в том виде, в каком они были в другом коммите, вы должны увидеть git-restore[1], в частности, --source опцию. Будьте осторожны с этими альтернативами, поскольку оба варианта отменят незафиксированные изменения в вашем рабочем каталоге.

Смотрите "Сброс, восстановление и возврат" в git[1], чтобы узнать о различиях между тремя командами.

git revert HEAD~3
Отмените изменения, указанные в четвертом последнем коммите в HEAD, и создайте новый коммит с отмененными изменениями.

git revert -n master~5..master~2
Верните изменения, сделанные фиксациями, с пятого последнего коммита в master (входит в комплект) на третий последний коммит в master (входит в комплект), но не создавайте никаких коммитов с отмененными изменениями. Возврат изменяет только рабочее дерево и индекс.


## rebase git-перебазирование - повторное применение коммитов поверх другого базового совета

Если <branch> указано, git rebase автоматически выполнит git switch <branch>, прежде чем делать что-либо еще. В противном случае он остается в текущей ветке.

Если <upstream> не указано, будут использоваться параметры восходящего потока, настроенные в branch.<name>.remote и branch.<name>.merge (подробнее см. git-config[1]), и предполагается, что используется --fork-point опция. Если вы в данный момент не находитесь ни в одной ветке или если у текущей ветки нет настроенного восходящего потока, перебазирование будет прервано.

Все изменения, внесенные коммит-ами в текущей ветке, но отсутствующие в <upstream>, сохраняются во временной области. Это тот же набор коммитов, который был бы показан с помощью git log <upstream>..HEAD; или с помощью git log 'fork_point'..HEAD, если --fork-point активен (см. Описание --fork-point ниже); или с помощью git log HEAD, если --root указана опция.

## Заключение



