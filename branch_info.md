# Работа с системой отслеживания версий Git

Система Git была изначально разработана в 2005 году Линусом Торвальдсом — создателем ядра операционной системы Linux. Git применяется для управления версиями в рамках колоссального количества проектов по разработке ПО, как коммерческих, так и с открытым исходным кодом.


![Линус Торвальдс - создатель ядра ОС Linux](https://filearchive.cnews.ru/img/news/2020/07/06/linus600.jpg)


## Установка
Установим сам Git.

* **Windows**. Проходим по этой ссылке <https://git-scm.com/download/win>, выбираем под вашу ОС (32 или 64 битную), скачиваем и устанавливаем.

* **Для Mac OS**. Открываем терминал и пишем:
```
#Если установлен Homebrew
brew install git

#Если нет, то вводим эту команду. 
git --version
#После этого появится окно, где предложит установить Command Line Tools (CLT).
#Соглашаемся и ждем установки. Вместе с CLT установиться и git
```
* **Linux**. Открываем терминал и вводим следующую команду.
``````
# Debian или Ubuntu
sudo apt install git

# CentOS
sudo yum install git
``````
## После загрузки Git Вам необходимо представиться. Первый шаг: установка имени пользователя и почты
**git config --global user.name "<ваше_имя>"**

**git config --global user.email "<адрес_почты@email.com>"**

*Если вам интересно, можете проверить версию Git командой*
**git --version**

## Создание папки и инициализация репозитория
Репозиторием называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске. Это осуществляется командой **git init**. Каждая точка сохранения вашего проекта носит название коммит *(commit)*. У каждого commit-a есть *hash* (уникальный id) и комментарий. Из таких commit-ов собирается ветка. **Ветка** - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.
Все эти commit находятся в ветке под названием main. Это основная ветка, чаще всего ее называют master.
# ***Систему Git можно представить следующим образом:***
 Каждый кружок, это commit. Стрелочки показывают направление, из какого commit сделан следующий. Например C3 сделан из С2 и т. д. Все эти commit находятся в ветке под названием main. Это основная ветка, чаще всего ее называют master . Прямоугольник main* показывает в каком commit мы сейчас находимся, проще говоря указатель.


![Схема Git](https://habrastorage.org/getpro/habr/upload_files/81d/ab6/de0/81dab6de02b4179fc1bc8c119dfce9ca)

  В итоге получается очень простой граф, состоящий из одной ветки (main) и четырех commit.
## Cправка
Справку по командам git можно получить, введя в термиле **git help**
# Основные команды:
* **git status** - проверка статуса git
* **git init** - инициализация репозитория
* **git add**-добавление файл в отслеживание версий
* **git commit  -m (-a)**- добавление комментариев, -а пропускает этап add, но при условии, что файл уже отслеживается
* **git log**
* **git checkout hash** - перекрючение на коммит по hash-номеру
* **git diff** - показать различие в версиях c последнего коммита
* **git branch --unset-upstream** - очистка дерева, переход в main
# Attention!
Не стоит после каждого изменения файла делать **commit**. Чаще всего их создают, когда:
+	Создан новый функционал
+	Добавлен новый блок на верстке
+	Исправлены ошибки по коду
+	Вы завершили рабочий день и хотите сохранить код
Это поможет держать вашу ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

![Малахов завершает передачу](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQTzXWPbdwzn09FGOjHHsHCTHuSaZrt2VtXVoIZXqVc81uZhOx-KqnpJXt-oe1QN1-xfxk&usqp=CAU)



***Материал создан по информации с первых лекций и семинаров на платформе GeekBrains, а также <https://habr.com/ru/articles/541258/>***



# **Work with branches in Git**
Начнем с юмора или что случиться, если доступ к проекту есть у всех ваших друзей

![Шутка](https://habr.com/share/publication/267025/96d94f088316a4e4977ad992a912d744/)


**Ветка** - это набор commit, которые идут друг за другом. У ветки есть название, основную ветку чаще вс
его называют master. Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.
* ?Не рекомендуется создавать commit напрямую в master. Лучше для этого заводить новую ветку и все изменения писать там.*
Для того, чтобы создать новую ветку вводим:
* **git branch <название_ветки>**
* **git checkout -b <название_ветки>**

При создuoании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка.

## Основные кlkоманды для работы с ветками в Git:
+ **git branch** - вывести ветку (или все)
+ **git branch feature/branch** -- создание ветки
+ **git checkout branch_name** -- переместиться на ветку
+ **git checkout -b branch_name** -- создать и переместиться
+ **git branch -d branch_name** -- удаление ветки
+ **git reset --hard-HEAD~3** -- опасная команда, HEAD~3, показывает число commit-ов, которые мы хотим удалить
# После завершения рjаботы в ветке можно сделать:

Можно посмотреть дерево (граф) Ваших изменений в ветках командой **git log --graph**

После того, как вы завершили работу над своей задачей, ветку можно слить в master . Для этого нужно переключиться в ветку master и выполнить следующую команду:
``````
# Переключаемся в master (или main)
git checkout master
# Обновляем локальную ветку с сервера, это нужно , чтобы не потерять свою копию на ПК ( в случае поломок)
**git pull origin master**

# Делаем merge вашей ветки, в ветку в которой вы находитесь
# В данном примере это master
**git merge <название_ветки>**

``````

Для того чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду: **git status**

?Совет. Каждый коммит, лучше заливать сразу в удаленный репозиторий. Никто не застрахован, поломки собственного ПК. Поэтому чтобы не потерять все наработки, не забывайте сливать ваши изменения на GitHub.


# Посмотреть и внести изменения в ветку можно командой

**git diff <исходная_ветка> <целевая_ветка>**






Всего хорошего! Берегите себя и своих близких!


![Шутка про add](https://sun7-23.userapi.com/impg/WqZ-5SUeV4g8lNxIdlOlbpCA28zJy4H5BVB83Q/uBXgzOVJV8k.jpg?size=545x807&quality=96&sign=9443131269019ea2ed5f96af3593e4fa&c_uniq_tag=UHzUU8XHVEIuMxAsaCGkQlXOLL881vX71zWmYTBtJfgrtherCY&type=album)

За основу данного Markdown взяты материалы 2-го семинары и лекции на платформе GeekBrains, а также материалы статьи Habr <https://habr.com/ru/articles/542616/>



# **Урок 3. Работа с удаленными репозиториями**

Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. 

## Просмотр удаленных репозиториев
* **git remote** - просмотреть список настроенных удалённых репозиториев/ Если вы клонировали репозиторий, то увидите как минимум **origin** — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование

* **git clone <адрес репозитория>** - клонирования репозитория
*  **git branch -M main** - переименование ветви master в main
 
* **git push -u origin main** - отправляем репозиторий
* **git push --set-upstream origin <Git1>** - отправляем текущую версию на текущей ветке
* **git pull**
* **git remote add <shortname> <url>** - добавление удалённых репозиториев
* **git remote show origin** - выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните git pull, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных

# Удаление и переименование удалённых репозиториев

Для переименования удалённого репозитория можно выполнить **git remote rename**. Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи **git remote rename**:
``````
$ git remote rename pb paul
$ git remote
origin
paul
``````
**Создание репозитория на GitHub**

Переходим на сайте GitHub <https://github.com>

1. New
2. Create repository

За основу данного Markdown взяты материалы 3-го семинара и лекции на платформе GeekBrains, а также материалы статьи <https://docs.github.com/ru/get-started/getting-started-with-git/managing-remote-repositories>
