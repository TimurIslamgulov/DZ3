# <p style="text-align: center;"><span style="color:purple">**Помощь при работе с Git**</p>

## <span style="color:red">**Основные команды**

* <span style="color:green">**git help**

* <span style="color:green">**git help <название_команды>**</span> по конкретной команде. Например, clone: git help clone

* <span style="color:green">**git config --global user.name "Name Lastname"**</span> указание имени пользователя

* <span style="color:green">**git config --global user. email user@mail.ru**</span> указание email пользователя

* <span style="color:green">**git --version**</span> установленная версия Git

* <span style="color:green">**git config --list**</span> проверка текущих настроек

* <span style="color:green">**git status**</span> Показывает состояние файлов в рабочей директории и индексе: какие изменены, но не добавлены в индекс; какие ожидают коммита в индексе. + подсказки, как изменить состояние файлов

* <span style="color:green">**git clean**</span> Удаляет мусор из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний
<span style="color:green">**clear**</span> очищает терминал

* <span style="color:green">**git init**</span> Когда создан проект (папка) и написаны первые строки кода, нужно инициализировать проект. Превращает папку в репозиторий, где Git  начинает отслеживать файлы и их изменения. Делается единожды

* <span style="color:green">**git add название_файла**</span> Перед сохранением созданные файлы и изменения нужно проиндексировать
* <span style="color:green">**git add .**</span> Можно использовать эту команду, если создано много файлов или внесено много изменений к ним.

* <span style="color:green">**git commit**</span> Сохраняет текущее состояние рабочего репозитория

* <span style="color:green">**git commit -m "название коммита"**</span> после индексации файлы можно закоммитить (сохранить)

* <span style="color:green">**git commit -am "название коммита"**</span> Позволяет одновременно проиндексировать файлы (за которыми уже ведется слежка) и закоммитить их

* <span style="color:green">**git log**</span> покажет пару последних коммитов
* <span style="color:green">**git reflog**</span> выведет список всех коммитов. Чтобы выйти из списка, нажать "Q"

* <span style="color:green">**git log -p**</span> Позволяет подробно изучить изменения, внесенные в каждый файл

* <span style="color:green">**git diff**</span> Просмотр разницы между текущим состоянием и последним коммитом. Или для сравнения других коммитов (для этого через пробел нужно ввести две четверки первых букв имен необходимых коммитов). Перед переключением версии файла в Git использовать git log, чтобы увидеть количество сохранений

* <span style="color:green">**fast-forward**</span>

## <span style="color:red">**Дерево коммитов**
HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем. HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD. Обычно HEAD указывает на имя ветки. Когда вы делаете коммит, статус ветки этого коммита меняется и это изменение видно через HEAD.

Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту. Для этого на последнем коммита набрать <span style="color:green">**git checkout идентификатор_коммита** </span>(hush)

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
* Перемещение на один коммит назад ^ (оператор каретки). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

* <span style="color:green">**git checkout main^**</span> означает "первый родитель ветки main".  (При прочих равных иногда требуется уточнить "родителя" для программы: ^1-более ранний или ^2-более поздний)

* <span style="color:green">**git checkout main^^**</span> означает прародитель (родитель родителя) main

* <span style="color:green">**git checkout HEAD^**</span> Можно также использовать HEAD как относительную ссылку

* <span style="color:green">**git checkout HEAD~<число>**</span> Перемещение на несколько коммитов назад  . Укажем после ~ число коммитов, через которые надо пройти. К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти.

* <span style="color:green">**git checkout HEAD~^2~2**</span> - можно комбинировать модификаторы. При этом ^2 указывает, что доходим до более позднего "родителя", а дальше перепрыгиваем 2 коммита

# <span style="color:red">**Ветвления**

* Ветка - это набор commit, которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master/main

* Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master

*! Не рекомендую создавать commit напрямую в master . Лучше для этого заводить новую ветку и все изменения писать там.*

* <span style="color:green">**git branch**</span> выводит список всех веток, * отмечена та, в которой находимся

* <span style="color:green">**git branch <название_ветки>**</span> создание новой ветки

* <span style="color:green">**git checkout -b <название_ветки>**</span> создание ветки и позволяет сразу переключиться в новую ветку. Вносить изменения в новую ветку можно сразу после ее создания.

! При создании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка. Например вот так: 3424_fix_catalog_ajax*

В каждом новом commit следует оставлять коммент и в нем описывать суть изменений.

* <span style="color:green">**git checkout <название_ветки>**</span> переключение между ветками.

После завершения работы над своей задачей ветку можно слить в master. Для этого нужно переключиться в ветку master <span style="color:green">**git checkout master**</span> 

* <span style="color:green">**git merge <сливаемая_ветка>**</span> Делаем слияние вашей ветки в ветку, в которой вы находитесь. Команда merge берет все изменения из ветки и добавляет их в ветку master.

*❗️ Перед тем как сливать новый merge, стоит обновить локальную ветку master во избежании дальнейших проблем.*

* <span style="color:green">**git merge --abort**</span> откат слияния веток

Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место. Делаются чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете <span style="color:green">**git rebase название_ветки**</span>.

Другие пользователи не увидят вашу ветку, пока она не будет отправлена на удаленный репозиторий. Поэтому, после того как вы слили все изменения в master , нужно отправить их в GitHub. Для этого обязательно нужно находиться в ветке master <span style="color:green">**git checkout master**</span>

Отправляем наши изменения в GitHub <span style="color:green">**git push origin master**</span>

Таким же образом можно отправить любую другую ветку <span style="color:green">**git checkout <название_ветки>**</span>

<span style="color:green">**git push origin <название_ветки>**</span>

*! Каждый коммит лучше заливать сразу в удаленный репозиторий. Никто не застрахован от поломки собственного ПК. Поэтому, чтобы не потерять все наработки, не забывайте сливать ваши изменения на GitHub.*

* <span style="color:green">**git diff <исходная_ветка> <целевая_ветка>**</span> Просмотреть изменения относительно двух веток можно командой 

* <span style="color:green">**git branch -d <название_ветки>**</span> удалить ненужную ветку

* <span style="color:green">**git log**</span> просмотр истории ветки

* <span style="color:green">**git log graph**</span> визуальное отображение ветвлений коммитов

### <span style="color:red">**Конфликты**

Иногда возникают конфликты. Например, когда в двух ветках были изменения в одной и той же строчке кода. Если такое произошло, то необходимо разрешить конфликт вручную. Для этого откройте файл там, где этого произошло.


Внести нужные изменения, добавить ваш файл через <span style="color:green">**git add <имя_файла>**</span> как измененный и создать новый commit.


## <span style="color:red">**Отмена изменений**

* <span style="color:green">**git reset название_предыдущей_ветки**</span> отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории". перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удаленных ветках, которые используют другие пользователи.

* <span style="color:green">**git revert название_измененной_ветки**</span> чтобы отменить изменения и поделиться (<span style="color:green">git push</span>) отмененными изменениями с остальными. 

## <span style="color:red">**Перемещение изменений**

* <span style="color:green">**git branch -f main HEAD~3**</span> переместит (принудительно) ветку main на три родителя назад от HEAD (branch forcing - перемещение ветки)

* <span style="color:green">**git cherry-pick <Commit1> <Commit2> <...>**</span> Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD) в заявленной последовательности. Удобно, когда точно известно, какие коммиты нужны (и известны их точные хеши). Поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)

* <span style="color:green">**git rebase -i HEAD~4**</span>- когда точно не известно какие коммиты нужны, можно использовать интерактивный rebase и отобрать нужный набор коммитов. Также показываются хеши коммитов и комментарии к ним.
После открытия окна интерактивного rebase есть три варианта для каждого коммита:
- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
- Можно соединить коммиты. При помощи этой функции можно объединять изменения двух коммитов.

При каждом перемещении коммиты получают по апострофу. Также апостроф добавляется, когда мы делаем <span style="color:green">**git commit --amend**</span>. 


* <span style="color:green">**rebase**</span>

* **git rebase куда_копируем какую_ветку_копируем** Rebase на нескольких ветках. При указании адреса последнего коммита копируемой ветки копируется вся ветка

reset начать всё с чистого листа

# <span style="color:red">**Теги**
Ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние. Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка. Основная задача тегов ссылаться постоянно на конкретный коммит. После создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений.

* <span style="color:green">**git tag название_тега адрес_тега**</span> создание тега. Если конкретный коммит не указан, гит пометит тегом HEAD. Для назначения тега не нужно специально переходить в ветку тега

* <span style="color:green">**git describe <ref>**</span> показывает, как далеко текущее состояние от ближайшего тега, где ref — это что-либо, что указывает на конкретный коммит, точку отсчета. Если не указать ref, то git будет считать, что указано текущее положение (HEAD). Помогает сориентироваться после отката на много коммитов по истории изменений.

Вывод команды выглядит примерно так: <tag>_<numCommits>_g<hash>, где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается (точка отсчета).

* <span style="color:green">**git bisect**</span>


# show commands покажет все доступные инструкции. Там есть очень полезные, например undo и reset
А пока просто начни игру при помощи levels

## <span style="color:red">**Синтаксис языка Markdown**

**Жирный текст** - ** или __ по обеим сторонам текста, который необходимо выделить

*Курсивный текст* - * или _ по обеим сторонам текста, который необходимо выделить

Вариативность * или _ нужна для того, чтобы при необходимости использовать единовременно в тексте оба инструмента, например: *джуны ленивые и хотят __ничего не делать__ и __зарабатывать много денег__*

 ~Зачеркнутый текст~ - ~по обеим сторонам текста, который необходимо выделить

Показать уровень заголовка - подчеркивание знаками = или ****

1, 2, 3... - нумерованные списки обозначаются обычными цифрами

* Ненумерованные списки обозначаются * в начале строки

Вложенные списки - выполняем отступы

<span style="color:green">**Выделение текста цветом**</span>
    
Вставка изображения. Загрузить в рабочую папку изображение, проиндексировать и закоммитить его. Скопировать относительеый путь изображения. Ввести ![название_для_изображения](имя_файла)

![pict](pict.jpg)

Переход по ссылке - <путь> 
<https://use-web.ru/news.php?id=138&tid=3>

Вставка цитаты 
>Здесь цитата
>в которой перед каждой новой строкой
>ставится угловая скобка

# <span style="color:red">**Инструкция для работы с удаленным репозиторием**

## <span style="color:red">**Как опубликовать в GitHub**

Если ваш проект пустой, то создайте новый файл и назовите его index.html . После этого откроется окно редактирование этого файла. Напишите в нем ! и нажмите кнопку Tab . Автоматически должен сгенерироваться скелет пустой HTML страницы. Не забудьте нажать ctrl+s чтобы файл сохранился.

Давайте теперь перейдем во вкладу для работы с Git-ом.

После того, как выбрали "Опубликовать на GitHub публичный репозиторий", программа предложит вам выбрать файлы, которые будут входить в первый commit. Проставляем галочки у всех файлов, если не проставлены и жмем ОК . Вас перекинет на сайт GitHub, где нужно будет подтвердить вход в аккаунт. Вы создали и опубликовали репозиторий на GitHub.

Если вы хотите создать локальный репозиторий и опубликовать код в другой сервис, то необходимо нажать на кнопку Initialize Repository . После этого, вручную выбрать сервис куда публиковать.


### Теперь сделаем изменения в коде и попробуем их снова опубликовать. Перейдите во вкладку с файлами, отредактируйте какой-нибудь файл, не забудьте нажать crtl+s (Windows) или cmd+s (MacOS), чтобы сохранить файл. Вернитесь обратно во вкладу управления Git. Если посмотреть на значок вкладки Git, то можно увидеть цифру 1 в синем кружке. Она означает, сколько файлов у нас изменено и незакоммичено. Давайте его закоммитим и опубликуем:

*1. Кнопка для просмотра изменений в файле. Необязательно нажимать, указал для справки*

*2. Добавляем наш файл для будущего commit*

*3. Пишем комментарий*

*4. Создаем commit*

*5. Отправляем наш commit в GitHub*

## <span style="color:red">**Как скачать с GitHub**

Если у вашего друга раньше не было проекта, то ему придется его "клонировать" себе: **git clone <адрес_репозитория>**

*! Адрес репозитория на GitHub можно получить, нажав на зеленую кнопку Code*

После выполнения команды в папке, где появится проект и ваш друг сможет с ним работать, все ветки и их история также подтянутся.

Перед тем, как создавать новый функционал и новую ветку, стоит обновить master на вашем устройстве. Для этого нужно находиться в этой ветке и выполнить следующую команду **git checkout master**

Подтягиваем изменения из репозитория GitHub **git pull origin master**

Таким же образом можно актуализировать любую другую ветку, заменив название ветки master на вашу.

*! Для обновления всех веток сразу, можно использовать такую, команду, но не рекомендую **git pull***

Теперь можно создавать новую ветку и кодить.

# <span style="color:red">**Полезные ссылки**

* Git-тренажер <https://learngitbranching.js.org/?locale=ru_RU>

* <https://vimeo.com/showcase/5616060>

* <https://www.atlassian.com/ru/git/tutorials/undoing-changes>

* <https://t.me/iksergeyru/6>

* <https://smartiqa.ru/courses/git/lesson-5>

* <https://gb.ru/posts/soveti-pro-git>
