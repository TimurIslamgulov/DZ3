**Инструкции и запросы в GIT**

1. Завести новый репозиторий очень просто, это делается командой 
>>*git init*

2. Если вы хотите присоединиться к разработке уже имеющегося проекта, то вам нужно будет скопировать этот репозиторий в свою локальную папку с удаленного репозитория. Делается это так:

>>*git clone <url удаленного репозитория>*

>>**Рабочая директория** – это файлы в корне проекта, тот код с которым вы работаете.
Локальный репозиторий — она же директория “.*git*”. В ней хранятся коммиты и другие объекты.
**Удаленный репозиторий** – тот самый репозиторий который считается общим, в который вы можете передать свои коммиты из локального репозитория, что бы остальные программисты могли их увидеть. Удаленных репозиториев может быть несколько, но обычно он бывает один.
Есть еще одна область, с пониманием которой обычно бывают проблемы. Это так называемая область **подготовленных изменений (staging area)**. Дело в том, что перед тем как включить какие-то изменения в коммит, нужно вначале отметить что именно вы хотите включить в этот коммит. В своей рабочей директории вы можете изменить несколько файлов, но в один конкретный коммит включать не все эти изменения.

>>В целом работа с гитом выглядит так: вы меняете файлы в своей рабочей директории, затем добавляете эти изменения в *staging area* используя команду

>>*git add <имя/файла>*

>>При этом можно использовать маски со звездочкой.
Потом вы делаете коммит в свой локальный репозиторий

*git commit –m “Комментарий к коммиту”*

>>Когда коммитов накопиться достаточно много, чтобы ими можно было поделиться, вы выполняете команду

*git push*

>>После чего ваши коммиты уходят в удаленный репозиторий.

Если нужно получить изменения из удаленного репозитория, то нужно выполнить команду

*git pull*

>>После этого, в вашем локальном репозитории появятся те изменения, которые были отправлены другими программистами.

>>Код в рабочей области проекта образуется применением тех изменений, которые содержаться в коммитах. У каждого коммита есть свое имя, которое представляет собой результат хеш функции sha-1 от содержимого самого коммита.

Просмотреть коммиты можно при помощи команды

*git log*

>>Формат ответа этой команды по дефолту не очень удобен. Вот такая команда выведет ответ в более читаемом виде

*git log --pretty=format:"%H [%cd]: %an - %s" --graph --date=format:%c*

>>Что бы закончить просмотр нужно нажать на клавишу q
Посмотреть, что находиться в рабочей директории и *staging area* можно командой

*git status*

>>Рабочую директорию можно переключить на предыдущее состояние выполнив команду

*git checkout <hash коммита>*

>>Только перед тем как это делать выполните *git status* и убедитесь, что у вас нет никаких локальных и не зафиксированных изменений. Иначе Git не поймет, как ему переключаться. *git status* подскажет вам что можно сделать с локальными изменениями что бы можно было переключиться. Этого правила следует придерживаться и при всяких других переключениях рабочей области.

***Ветка***

>>Ветка в Git это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита. Визуально это можно представить вот так.

>>Сделать новую ветку и переключиться на нее можно выполнив команды

*git pull*
*git checkout –b <имя новой ветки>*

>>Просто сделать ветку, не переключаясь на нее можно командой

*git branch <имя ветки>*

>переключиться на ветку

*git checkout <имя ветки>*

>>Важно понимать, что ветка берет свое начало не от ветки, а от последнего коммита который находиться в той ветке, в которой вы находились.

>>Ветка обычно заканчивается специальным merge коммитом, который говорит, что ветку нужно объединить с какой-то другой веткой. В merge коммите содержатся две ссылки на два коммита которые объединяются в одну ветку.

>>Существует другая ситуация при объединении веток, в которой *merge* может произойти без *merge commit*. Дело в том, что если в одной из веток не произошло никаких изменений, то необходимость в *merge commit* с двумя предками отпадает. В таком случае, при слиянии веток, Git просто сделает пометку о том, что дальше будут идти коммиты той ветки с которой эта ветка была объединена. Такая схема merge называется слияние-перемотка (*fast-forward merge*).

>>Во всех этих случаях, после того, как ветка объединяется с другой веткой, все коммиты сделанные в ней, попадают в ветку с которой она была объединена. Так же важно понимать, что merge это не двунаправленная операция. Если смержить ветку задачи в мастер ветку, то в мастер ветке появится код, который находился в ветке задачи, а в ветке задачи не появиться новый код из мастер ветки. Если нужно что бы это произошло, нужно смержить мастер ветку в ветку задачи.
Что бы смержить одну ветку в другую нужно вначале переключиться на ту ветку, в которую вы хотите смержить

*git checkout <имя ветки>*

>>Потом получить последние изменения сделанные в этой ветке выполнив

*git pull*

>>Затем выполнить команду

*git merge <имя ветки>*

>>Так выглядит работа с ветками в общих чертах.

>>Обратите внимание на то, что перед тем как заводить новую ветку нужно выполнить *git pull*. Делается это по нескольким причинам.
Другой программист мог изменить код, в том числе внести такие изменения, которые повлияют на решение задачи, для которой вы заводите новую ветку. Эти изменения могут вам пригодиться при решении своей задачи.
Из-за этих изменений вы можете получить конфликт при мерже.
Больше шанс что у вас получится *merge commit*. Это не так плохо, как два предыдущих пункта. Но если можно избежать лишнего коммита, то почему бы этого не сделать?

**Популярные схемы работы с ветками в Git**


>>Теперь можно описать популярные схемы работы с ветками в гите.

>>Ветки нужны для того, чтобы программисты могли вести совместную работу над проектом и не мешать друг другу при этом. При создании проекта, Git создает базовую ветку. Она называется master веткой. Она считается центральной веткой, т.е. в ней содержится основной код приложения.

***Классическая схема работы с ветками***

>>Обычно перед тем как взяться за решение какой-то задачи, программист заводит новую ветку от последнего рабочего коммита мастер ветки и решает задачу в этой новой ветке. В ходе решения он делает ряд коммитов, после этого тестирует код непосредственно в ветке задачи. А после того как задача решена, делают merge обратно в мастер ветку. Такую схему работы часто используют с юнит тестами и автоматизированным деплоем. Если юнит тесты будут покрывать весь код, то можно настроить деплой так, что вначале будут прогоняться все тесты в ветке задачи. А после этого, если они прошли успешно, будет происходить merge и деплой. При такой схеме можно добиться полной автоматизации при тестировании и деплои.

**Именная ветка**

>>Неопытные программисты заводят себе именную ветку и работают всегда в ней. Они решают по одной задачи за раз, и когда заканчивают решение одной из задач, делают новый Pull запрос через Web интерфейсе (об этом чуть ниже). Недостаток этого подхода в том, что так можно решать только одну задачу и нельзя быстро переключиться на решение другой задачи. Еще один недостаток в том, что ветки так со временем будут все сильнее расходиться и код в ветке программиста рано или поздно устареет относительно мастер ветки и его придется обновить. Для этого можно либо смержить мастер ветку в ветку программиста, либо завести новую ветку для этого программиста от последнего рабочего состояния в мастер ветке. Правда к тому времени, как это произойдет программист уже может освоить гит в достаточной мере что бы перейти на “классическую” схему работы. Таким образом эта схема имеет место быть для неопытных пользователей Git.

**Схема с dev веткой**

>>Другая схема очень похожа на классическую, только в ней помимо мастер ветки есть еще девелоперская ветка, которая деплоится на тестовый сервер. Такую ветку обычно называют dev. Схема работы при этом такая. Программист перед выполнением новой задачи заводит для нее ветку от последнего рабочего состояния в мастер ветке. Когда он заканчивает работу над задачей, то мержит ветку задачи в dev ветку самостоятельно. После этого, совместными усилиями задача тестируется на тестовом сервере вместе с остальными задачами. Если есть ошибки, то задачу дорабатывают в той же ветке и повторно мержат с dev веткой. Когда тестирование задачи заканчивается, то ВЕТКУ ЗАДАЧИ мержат с мастер веткой. Важно заметить, что в этой схеме работы с мастер веткой нужно мержить ветку задачи, а не dev ветку. Ведь в dev ветке будут содержаться изменения, сделанные не только в этой задаче, но и в других и не все эти изменения могут оказаться рабочими. Мастер ветка и dev ветка со временем будут расходиться, поэтому при такой схеме работы периодически заводят новую dev ветку от последнего рабочего состояния мастер ветки. Недостатком этого подхода является избыточность, по сравнению с классической схемой. Такую схему работы с ветками часто используют если в проекте нет автоматизированных тестов и все тестирование происходит вручную на сервере разработки.

>>Так же следует отметить что эти схемы работы можно комбинировать между собой, если в этом есть какая-то необходимость.

**Pull запросы**

>>С этим понятием имеется путаница. Дело в том, что в Git есть две совершенно разные вещи, которые можно назвать Pull запросом. Одна из них, это консольная команда *git pull*. Другая это кнопка в web интерфейсе репозитория.

>Про эту кнопку и пойдет речь дальше.

>>Если программист достаточно опытный и ответственный, то он обычно сам сливает свой код в мастер ветку. В противном случае программист делает так называемый Pull запрос. Pull запрос это по сути дела запрос на разрешение сделать merge. Pull запрос можно сделать из web интерфейса Git, или при помощи команды git request-pull. После того как Pull запрос создан, остальные участники могут увидеть это, просмотреть тот код который программист предлагает внести в проект, и либо одобрить этот код либо нет. Merge через pull запросы имеет свои плюсы и минусы. Минус в том, что для тесной команды опытных программистов такой подход будет лишним. Это будет только тормозить работу и вносить в нее оттенки бюрократии.

>>С другой стороны, если в проекте есть не опытные программисты, которые могут сломать код, то Pull запросы могут помочь избежать ошибок, и быстрее обучить этих программистов наблюдая за тем какие изменения они предлагают внести в код.

>>Так же Pull запросы подходят для широкого сообщества программистов, работающих с открытым исходным кодом. В этом случае нельзя заранее сказать что-то о компетенции таких разработчиков и о том, что они хотят изменить в коде.

**Конфликты**

>>Конфликты возникают при мердже веток если в этих ветках одна и та же строка кода была изменена по-разному. Тогда получается, что Git не может сам решить какое из изменений нужно применить и он предлагает вручную решить эту ситуацию. Это замедляет работу с кодом в проекте. Избежать этого можно разными методами. Например, можно распределять задачи так, чтобы связанные задачи не выполнялись одновременно различными программистами.
Другой способ избежать этого, это договориться о каком-то конкретном стиле кода. Тогда программисты не будут менять форматирование кода и вероятность того, что они изменят одну и ту же строчку станет ниже.

>>Еще один хороший совет, который поможет вам избежать конфликтов при работе в команде, это вносить минимум изменений в код при решении задач. Чем меньше строчек вы поменяли, тем меньше вероятность что вы измените ту же самую строку что и другой программист в другой задаче.

>>После того, как в мастер ветке достигается состояние, которое можно считать стабильным оно отмечается тегом с версией этого состояния. Это и есть то что называют версией программы.
>Делается это вот так

*git tag -a v1.0*

>>Что бы передать ветки в удаленный репозиторий нужно выполнить команду

*git push –tags*

>>Теги удобны еще и тем, что можно легко переключиться на то состояние кода которое отмечено тегом. Делается это с помощью все той же команды

*git checkout <имя тега>*

>>Различные системы деплоя и автоматизированной сборки используют теги для идентификации того состояния, которое нужно задеплоить или собрать. Так сделано потому, что если мы будем собирать или деплоить код последней версии, то есть риск, что какой-то другой программист в этот момент внесет какие-то изменения в мастер ветку, и мы соберем не то что хотели. К тому же так будет проще переключаться между рабочими и проверенными состояниями проектов.

>>Если вы будете придерживаться этих правил и “классической” схемы работы с ветками, то вам будет проще интегрировать ваш Git с другими системами. Например, с системой непрерывной интеграции или с репозиторием пакетов, таким как packagist.org. Обычно сторонние решения и всякие расширения рассчитаны именно на такую схему работы с гитом, и если вы сразу начнете делать все правильно, то это может стать большим плюсом для вас в дальнейшем.

>>Это обзор основных моментов при работе с Git. Если вы хотите узнать про Git больше, то я вам посоветую прочитать книгу Pro Git.

**Всем хорошего дня**
**Хорошего настроения**

 >> **В общем** как начинаешь работать с кодом и файлами...сначала сохранил cntrl+s затем вводишь команды: *git add "здесь пишешь имя файла с расширением"* этим фиксишь изменения.

 >> затем комитишь, то есть создаешь сохранение как в играх, при помощи команды: *git comit -m "здесь коменты по сохранению, например просто save1"* Это сохранит файл в локале. ЧТо бы запушить на гитхаб, нужно сначала сконектится с ним и ввести команду: *git push* Тогда на гитхабе появится твой файл со всеми комитами. 
 
 
 ## Работа с удаленными репозиториями

>>Настройка репозитория
git init git clone git config

>>Этот обучающий материал включает в себя обзор настройки репозитория в системе контроля версий Git. На этой странице вы узнаете, как инициализировать репозиторий Git для нового или существующего проекта. Ниже представлены примеры жизненного цикла для репозиториев, созданных локально и клонированных из удаленных репозиториев. Для работы с этим руководством требуются начальные знания о работе с интерфейсом командной строки.


В данном руководстве обсуждаются следующие основные вопросы:

* Инициализация нового репозитория Git
* Клонирование существующего репозитория Git
* Коммит измененной версии файла в репозиторий
* Конфигурирование репозитория Git для удаленной совместной работы
* Распространенные команды для управления версиями Git
* По окончании данного модуля вы должны уметь создавать репозиторий Git, использовать основные команды Git, выполнять коммит измененного файла, просматривать историю проекта и настраивать соединение с сервисом хостинга Git (Bitbucket).

*Что такое репозиторий Git?*
Репозиторий Git — это виртуальное хранилище проекта. В нем можно хранить версии кода для доступа по мере необходимости.

*Инициализация нового репозитория: git init*
>>Для создания нового репозитория используется команда git init. Команду git init выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога .git в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.

>>Создание версии существующего проекта с использованием нового репозитория Git
В этом примере предполагается, что у вас уже есть папка проекта, в которой вы и хотите создать репозиторий. Выполните команду cd для перехода к папке проекта, а затем выполните команду git init.

*cd /path/to/your/existing/code 
git init*
>>Указание в команде git init существующего каталога проекта приведет к исполнению описанной выше инициализации, но только на уровне этого каталога проекта.

>>git init <project directory>
Перейдите на страницу git init, чтобы получить подробные сведения о команде git init.

>>Клонирование существующего репозитория: git clone
Если проект уже настроен в центральном репозитории, наиболее распространенным способом создать его локальный клон является команда clone. Клонирование, как и команда git init, обычно выполняется один раз. Получив рабочую копию, разработчик в дальнейшем выполняет все операции контроля версий из своего локального репозитория.

git clone <repo url>
>>Команду git clone выполняют для создания копии (клонирования) удаленного репозитория. В качестве параметра в команду git clone передается URL-адрес репозитория. Git поддерживает несколько различных сетевых протоколов и соответствующих форматов URL-адресов. В этом примере используется SSH-протокол Git. URL-адреса SSH в Git имеют следующий шаблон: git@HOSTNAME:USERNAME/REPONAME.git

Пример URL-адреса SSH в Git имеет вид: git@bitbucket.org:rhyolight/javascript-data-store.git, а ниже приведены значения шаблонных параметров:

HOSTNAME: bitbucket.org
USERNAME: rhyolight
REPONAME: javascript-data-store
После исполнения команды последние версии файлов из главной ветки удаленного репозитория будут загружены и помещены в новый каталог. Имя нового каталога будет соответствовать параметру REPONAME. В данном случае это javascript-data-store. В каталоге будет вся история удаленного репозитория и только что созданная главная ветка.

>>Дополнительную информацию об использовании команды git clone и поддерживаемых форматах URL-адресов в Git см. на странице git clone.

>>Сохранение изменений в репозитории: git add и git commit
>>У вас появился репозиторий, созданный путем клонирования или инициализации. Теперь вы можете выполнять коммиты изменений в версиях файлов. В следующем примере предполагается, что вы настроили проект в каталоге /path/to/project. В этом примере предлагаются следующие шаги.

>>Измените каталоги на /path/to/project
Создайте новый файл CommitTest.txt с текстом ~«тест для обучения работе с Git»~
С помощью команды git add добавьте файл CommitTest.txt в репозиторий проиндексированных файлов
Создайте новый коммит с комментарием, описывающим, что именно было изменено в коммите
cd /path/to/project 
echo "test content for git tutorial" >> CommitTest.txt 
git add CommitTest.txt 
git commit -m "added CommitTest.txt to the repo"
По завершении этого примера файл CommitTest.txt добавится к истории репозитория, и репозиторий будет отслеживать последующие изменения в файле.

>>В этом примере представлены две новые команды в Git: add и commit. Этот очень упрощенный пример. Подробнее обе команды объяснены на страницах git add и git commit. Команду git add часто используют с флагом --all. Команда git add --all добавляет все измененные и неотслеживаемые файлы в репозиторий и обновляет дерево изменений репозитория.

>>Совместная работа в разных репозиториях: git push
Важно понимать, что рабочая копия в Git существенно отличается от рабочей копии, получаемой при загрузке исходного кода из репозитория SVN. В отличие от SVN, в Git нет разницы между рабочими копиями и центральным репозиторием — все они являются полноценными репозиториями Git.

>>Поэтому совместная работа в Git принципиально отличается от совместной работы в SVN. В SVN работа строится на отношении между центральным репозиторием и рабочей копией, а модель совместной работы в Git основана на взаимодействии между репозиториями. Вместо загрузки рабочей копии в центральный репозиторий SVN в Git вы отправляете коммиты из одного репозитория в другой или копируете их в обратном направлении.

>>Вы легко можете задавать особую роль определенным репозиториям Git. Например, обозначив один из репозиториев Git как «центральный», вы можете воспроизвести централизованный процесс с использованием Git. Такой подход требует общих договоренностей, он не встроен в саму систему контроля версий.

>>Сравнение чистых и клонированных репозиториев
Если в предыдущем разделе («Инициализация нового репозитория») для настройки локального репозитория вы использовали команду git clone, ваш репозиторий уже готов к удаленной совместной работе. Команда git clone автоматически настроит репозиторий, в котором значение remote будет соответствовать URL-адресу Git, из которого был клонирован репозиторий. Это означает, что после изменений файла и выполнения коммита вы можете сразу выполнить команду git push, чтобы отправить эти изменения в удаленный репозиторий.

>>Если вы использовали команду git init для создания репозитория с нуля, у вас не будет удаленного репозитория, в который можно помещать изменения. Зачастую для инициализации нового репозитория пользователь переходит на сервис Git-хостинга (например, Bitbucket) и создает репозиторий там. Данный сервис предоставит URL-адрес Git, который затем можно добавить в локальный репозиторий Git. После этого можно выполнять команду git push в репозиторий на хостинге. После создания удаленного репозитория на выбранном хостинге вам понадобится обновить локальный репозиторий, выполнив привязку. Этот процесс описывается далее в руководстве по установке и настройке.

>>Если вы предпочитаете поддерживать собственный удаленный репозиторий, вам нужно создать «чистый репозиторий». Для этого команды git init и git clone принимают аргумент --bare. Наиболее популярная причина использования чистого репозитория — создание удаленного центрального репозитория Git

>>Конфигурирование и настройка: git config
После настройки удаленного репозитория его URL-адрес нужно добавить в локальный файл git config, а также создать вышестоящую ветку для локальных веток. Такую возможность предоставляет команда git remote.

git remote add <remote_name> <remote_repo_url>
Эта команда привяжет удаленный репозиторий по адресу  к ссылке в вашем локальном репозитории . После привязки удаленного репозитория в него можно будет отправлять локальные ветки с помощью команды push.

git push -u <remote_name> <local_branch_name>
Эта команда поместит ветку локального репозитория с именем < local_branc_name > в удаленный репозиторий < remote_name >.

>>>>Дополнительную информацию о команде git remote см. на странице удаленной работы в Git.

>>Помимо конфигурирования URL-адреса удаленного репозитория, вам может потребоваться установить глобальные параметры Git, например имя пользователя или электронный адрес. Команда git >>config позволяет настроить инсталляцию Git (или отдельный репозиторий) из командной строки. С помощью этой команды можно установить любые настройки: от информации о пользователе до его предпочтений и характеристик репозитория. Ниже перечислены распространенные варианты конфигурации.

>>Git хранит варианты конфигурации в трех различных файлах, позволяющих ограничивать область видимости на уровне отдельных репозиториев (локальный), пользователя (глобальный) или всей системы (системный):

>>Локальный: /.git/config — настройки на уровне репозитория.
Глобальный: /.gitconfig — настройки на уровне пользователя. Здесь хранятся настройки с флагом --global.
Системный: $(prefix)/etc/gitconfig — настройки на уровне всей системы.
Укажите имя автора, которое будет использоваться для всех коммитов в текущем репозитории. Обычно для настройки параметров конфигурации для текущего пользователя используется флаг --global.

git config --global user.name <name>
>>Эта команда задает имя автора, которое будет использоваться для всех коммитов, выполненных текущим пользователем.

>>Добавление аргумента --local или выполнение команды без параметра уровня конфигурации приведет к установке значения user.name для текущего локального репозитория.

git config --local user.email <email>
Эта команда задает адрес электронной почты автора, который будет использоваться для всех коммитов, выполненных текущим пользователем.

git config --global alias.<alias-name> <git-command>
Создайте быстрые клавиши для команды Git. Это мощная возможность для создания собственных комбинаций клавиш для часто используемых команд Git. Ниже показан упрощенный пример:

git config --global alias.ci commit
Так создается команда ci, которую можно использовать как сокращение команды git commit. Подробнее об алиасах в Git см. на странице git config.

git config --system core.editor <editor>
Выберите текстовый редактор, используемый для таких команд, как git commit, для всех пользователей текущего компьютера. Аргумент  должен представлять собой команду, запускающую нужный редактор (например, vi). В этом примере представлен аргумент --system. Аргумент --system устанавливает настройку на уровне всей системы, включая всех пользователей и все репозитории на компьютере. Дополнительную информацию об уровнях конфигурации см. на странице удаленной работы с git.

git config --global --edit
В текстовом редакторе откройте файл глобальной конфигурации для редактирования вручную. Подробное руководство по настройке текстового редактора для Git см. на странице Git config.

**Пояснения**
Все варианты конфигурации сохраняются в обычных текстовых файлах, так что команда git config — это всего лишь удобный интерфейс командной строки. Как правило, установку Git следует настраивать только при начале работы на новом компьютере. В подавляющем большинстве случаев понадобится только флаг --global. Одно из важных исключений — необходимость переписать электронный адрес автора. Вы можете поставить личный электронный адрес для личных репозиториев и репозиториев с открытым исходным кодом, а рабочий электронный адрес — для рабочих репозиториев.

>>Git хранит варианты конфигурации в трех различных файлах, что позволяет ограничивать область видимости на уровне отдельных репозиториев, пользователей или всей системы.

/.git/config — настройки на уровне репозитория.
~/.gitconfig — личные настройки пользователя. Здесь хранятся настройки с флагом --global.
$(prefix)/etc/gitconfig — настройки на уровне всей системы.
Если параметры, указанные в этих файлах, конфликтуют, локальные настройки переопределяют пользовательские настройки, которые в свою очередь переопределяют системные настройки. Если вы откроете один из этих файлов, вы увидите нечто подобное:

>>[user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim
Вы можете изменить эти значения вручную, эффект будет аналогичен использованию команды git config.

Пример
>>В первую очередь после установки Git требуется указать свое имя и адрес электронной почты, а также настроить некоторые параметры по умолчанию. Пример типичной начальной конфигурации показан далее.

Представьтесь репозиторию Git с помощью команды git config

git --global user.name "John Smith" git config --global user.email john@example.com
Выберите любимый текстовый редактор

git config --global core.editor vim
Добавьте алиасы по типу SVN

git config --global alias.st status 
git config --global alias.co checkout 
git config --global alias.br branch 
git config --global alias.up rebase 
git config --global alias.ci commit
Создастся файл ~ /.gitconfig, описанный в предыдущем разделе. Подробную информацию о команде git config см. на странице Git config.

Резюме
>>Мы показали, как создать репозиторий Git двумя способами: git init и git clone. Этим руководством можно пользоваться при необходимости управления исходным кодом ПО или другим контентом, при хранении которого требуется поддерживать версионность. Кроме того, были представлены команды git add, git commit, git push и git remote и показаны простые примеры их использования.

## Как сделать свой первый Pull Request

Это руководство научит вас делать изменения в проекте на GitHub. Описываемый процесс предлагает лучшие практики, и является достаточно распространённым — вы сможете применять его за пределами нашего сообщества. В проектах сообщества придерживаться такого процесса очень рекомендуется.

Сначала мы приведём высокоуровневое описание процесса, а затем подробно опишем каждый этап.

Предполагается знание основ системы контроля версий Git. Если вы ещё не работали с Git, мы дадим ссылки на официальную русскоязычную документацию по необходимым командам.

Вам также потребуется аккаунт на GitHub. Регистрация бесплатная и требует указания лишь имени пользователя и электронной почты.

Вот процесс с высоты птичьего полёта.

Форкните проект.
Склонируйте репозиторий.
Создайте ветку для своей работы.
Сделайте необходимые изменения в файлах — коде, документации, тестах. Закоммитьте их в только что созданную ветку.
Убедитесь, что проект работает после ваших изменений.
Сделайте Pull Request.
Обсудите его с рецензентом в процессе Code Review. При необходимости, внесите изменения в свой Pull Request.
Когда все довольны, Pull Request принимают — с этого момента ваши изменения попали в исходный репозиторий (upstream) и являются частью проекта.
Работа над задачей закончена!

Теперь рассмотрим каждый этап подробнее.

Форкаем проект
Вы не можете отправлять коммиты (git push) напрямую в исходный репозиторий. По желанию хозяин проекта может это разрешить, но обычно доступ на запись есть только у людей, поддерживающих проект, а все остальные работают через Pull Request’ы («запросы на вливание изменений»; о них — ниже).

Поэтому мы форкаем проект — это создаст копию репозитория в вашем аккаунте. При этом у вас появится доступ на запись в вашу копию.

Клонируем репозиторий
Затем нужно склонировать репозиторий на вашу локальную машину. Для этого нам нужен URL репозитория. Нажав на кнопку справа, вы скопируете его в буфер обмена. Обратите внимание на выбранный слева протокол. Если вы не настраивали SSH для GitHub, там должно быть указано HTTPS.

Затем выполняем команду в терминале (или командной строке Windows):

git clone <вставляем_URL>

Репозиторий склонируется в под-директорию текущей директории. Например, если репозиторий называется foobar, у вас появится каталог foobar.

Создаём ветку
Ветка по умолчанию — master. Чтобы изменениями было проще управлять и они не смешивались друг с другом, создадим отдельную ветку, где и будем работать. При этом ветку стоит назвать так, чтобы имя говорило о её назначении.

Например, мы хотим исправить ошибку в реализации протокола PROTOBAZ, так что наша ветка будет называться fix-protobaz.

Теперь заходим в наш склонированный репозиторий и создаём ветку:

1
2
cd foobar
git checkout -b fix-protobaz
Вторая команда создаст ветку и перейдёт на неё (сделает checkout).

Если после этого выполнить git status, он покажет

1
2
On branch fix-protobaz
nothing to commit, working directory clean
Эту команду стоит запомнить — когда не понимаете, в каком состоянии репозиторий, просто выполните её. Чаще всего в её выводе git покажет другие команды, которые делают то, что вы (скорее всего) и хотите сделать.

Делаем изменения
Теперь приступаем к работе. Редактируем код, обновляем документацию, чиним тесты, дополняем README.

Эти изменения мы коммитим в нашу ветку. Как это сделать — ниже.

При этом старайтесь делать коммиты часто, а сами коммиты — небольшими по объёму. Каждый коммит должен делать ровно одну вещь, и при этом поддерживать работоспособность проекта. Стремиться нужно к тому, чтобы в будущем можно было перейти на любой коммит и получить рабочий проект.

Если у вас сразу не получается придерживаться такой дисциплины, или изменения затрагивают весь проект «насквозь», допустимо ломать проект и постепенно чинить его в следующих коммитах.

Если вы уже достаточно разбираетесь в Git, такие не-атомарные изменения потом нужно объединить в один коммит с помощью interactive rebase и squash.

Итак, после редактирования файлов мы имеем следующую ситуацию (это вывод git status):

1
2
3
4
5
6
7
8
On branch fix-protobaz
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   src/protobaz.rs

no changes added to commit (use "git add" and/or "git commit -a")
В выводе есть все необходимые вам команды:

git add <file>... добавляет файл в содержимое коммита, который вы собираетесь записать
git checkout -- <file>... откатывает ваши изменения файла
Поэтому делаем git add src/protobaz.rs, а затем git commit. Откроется редактор, в котором нужно ввести сообщение коммита.

Сообщение коммита — это описание того, что вы сделали. Его читают другие участники проекта и рецензент. Поэтому оно должно быть осмысленным и читаемым.

Формат сообщения о коммите таков:

1
2
3
4
5
6
Краткое описание коммита (не более 50 символов)

Подробное описание коммита - зачем он сделан, почему нельзя сделать по-другому,
источники информации.

Служебная информация - теги, ссылки на задачи, какие задачи коммит закрывает.
Например,

1
2
3
4
5
6
7
8
Исправляем длину буфера в реализации PROTOBAZ

Неверное вычисление длины приводило к отсечению части сообщения в ситуации,
когда пользователь использует foobar-1.3.4.

Смотри http://foobar.org/bugs?id=1234

Fix #123
Из всех частей сообщения, только первая является обязательной.

Она должна иметь вид <Глагол в настоящем времени, первом лице, множественном числе> <объект изменения>. Говорим о том, что мы делаем в этом коммите: [мы] исправляем ошибку, [мы] добавляем возможность, [мы] обновляем документацию.

Последняя строка — это команда GitHub. Когда коммит с такой командой попадает в master, GitHub автоматически закроет указанную задачу. Можно использовать разные формы этой команды: Fix #123, fixes #123, close #123 и другие. Это экономит время на поддержку проекта.

В наших проектах нужно использовать Fix #123 или Close #123 на последней строке сообщения коммита.

git log --oneline выводит историю в формате «1 коммит — 1 строка на экране». При этом он использует в качестве описания коммита первую строку — краткое описание. Поэтому оно обязательно должно быть отделено пустой строкой от остального описания — иначе однострочный вывод разъедется.

Язык сообщения о коммите должен соответствовать принятому языку проекта. Поскольку наши проекты нацелены на русскоязычную аудиторию и разработчики говорят по-русски, сообщения коммитов также должны быть на русском.

Когда вы ввели сообщение коммита в редакторе, сохранили файл и закрыли его, можно выполнить git log и убедиться, что коммит записан в историю.

Проверяем изменения
Когда вы сделали правки, стоит их проверить — если только это не что-то абсолютно тривиальное.

Для этого нужно собрать проект и запустить тесты, если они есть. В любом случае стоит проверить работу кода, который вы написали или изменили, запустив программу или вызвав библиотеку.

Если проект — это статически генерируемый сайт, то сгенерируйте его локально и убедитесь, что ничего не отвалилось и вёрстка не разъехалась. Если книга — то же самое. Смотрите по крайней мере на те места, которые вы правили.

Создаём Pull Request
Когда работа и проверка закончены, пора создавать Pull Request. Pull Request — это запрос на вливание изменений из вашей ветки в основную ветку исходного репозитория. Таким образом они попадут к хозяевам проекта.

Чтобы создать Pull Request, зайдём на страницу вашего форка. Справа от выпадающего меню с выбором ветки есть кнопка «New pull request».

Нажимаем её.

Вы попадаете в окно сравнения веток.

Вот элементы этого окна, по порядку:

Базовый репозиторий, в который будет создаваться PR. Это должен быть репозиторий, от которого вы делали форк. Если вы форкнули проект ruRust/rustycrate.ru, а ваше имя пользователя GitHub — user, то у вас будет проект user/rustycrate.ru.
Базовая ветка в этом репозитории, обычно master.
Репозиторий, откуда должны вливаться изменения. Здесь должен быть выбран репозиторий в вашем аккаунте — user/rustycrate.ru.
Ветка, откуда будут вливаться изменения. Это должна быть ветка, которую мы создали в разделе «Создаём ветку».
Дальше просмотрите изменения — то ли это, что вы делали? Если да, то нажимайте кнопку «Create pull request». В моём примере её нет, т. к. ветки в форке и в оригинале находятся в одинаковом состоянии. В вашем же случае внизу будет список коммитов, которые попадут в исходный репозиторий, и, на других вкладках — сами изменения и комментарии к изменениям.

После нажатия кнопки появится окно ввода сообщения Pull Request.