# **Инструкция по использованию команд Git в Терминале**

## **Первая настройка Git**


1. git config --global user.name "name" - вводим свое имя, представляясь Git.

2. git config --global user.email "email@mail.ru" - вводим свою электронную почту.

## **Работа с репозиториями**


1. Чтобы создать репозиторий, нужно создать папку (лучше в корневом каталоге), перейти в нее и выполнить команду

git init - создает в новой папке скрытую папку .git и Git начинает отслеживать вносимые в созданную папку изменения (например, создание вложенных папок, файлов, изменения файлов).

2. Чтобы исключить некоторые элементы репозитория из отслеживания создаем скрытый файл 

.gitignore - файл, в который вносятся папки и файлы, которые Git будет игнорировать и не включать в отслеживание (например, папки Bin, Obj, *.txt, .gitignore).

3. git status - показывает состояние репозитория.

Любой файл в Git имеет 3 состояния:

* неослеживаемый (new file or modified)
* отслеживаемый (staged)
* зафиксированный (commited).



### **Основные этапы работы с файлами в Git:**


1. Создание файла или внесение в него изменений.

touch file_name - создаем файл;

echo "text" > file_name - вносим в него содержимое.

При выполнении команды git status будет отражено наличие неотслеживаемых файлов (untracked files).

Если внесли изменения в уже отслеживаемый файл, то команда git status покажет наличие неотслеживаемых изменений (modified).

2. Добавление файла в отслеживание (stage):

git add file_name - первое добавление файла в отслеживание;

git add . - добавляет в отслеживание все изменения в репозитории.

При выполнении команды git status будет отражено наличие изменений, готовых к фиксации (new file or modified). 

3. Фиксирование изменений в репозитории (commit):

git commit -m "Текст сообщения" - фиксирует все изменения в репозитории;

git commit -am "Текст сообщения" - добавляет в отслеживание измененные уже отслеживаемые файлы и одновременно фиксирует все изменения в репозитории.

При выполнении команды git status будет отражено отсутствие изменений, готовых к фиксации.

4. Просмотр истории изменений:

git log - выдает полный список коммитов (зафиксированных изменений);

git log --oneline - выдает список коммитов в кратком виде;

git log --graph - показывает список коммитов с визуализацией веток;

git log -p - показывает разницу между коммитами;

git reflog - выдает в усеченном виде полный список коммитов и переходов (checkout) по веткам;

git diff - покажет изменение в файле по сравнению с зафиксированным состоянием файла в последнем коммите;

git diff hesh_comm1 hesh_comm2 - покажет разницу между двумя коммитами, идентифицируемых по первым 4 знакам хешей (идентификаторов, указанных при выполнении команды git log);

git checkout hesh_comm - перешли на конкретный коммит для просмотра состояния файла на тот момент (указываются первые 4 знака хеша коммита).

5. Удаление файла:

git rm file_name - удаляет указанный файл.

### **Работа с ветками в Git:**


Для обеспечения командной работы и возможности одновременного внесения изменений разными разработчиками в один файл или создание одним разработчиком несколько версий одного файла, в Git предусмотрено создание веток:

1. git branch branch_name - создает ветку от текущего положения.

2. git branch -d branch_name - выполняется удаление ветки, при указании параметра -D выполняется принудительное удаление ветки. При удалении ветки необходимо с нее перейти на другую ветку.

3. git checkout branch_name - выполняется переход на указанную ветку.

4. git checkout -b branch_name - выполняется создание ветки и одновременный переход на нее.

5. git merge branch_name - выполняется слияние указанной ветки с веткой, на которой находитесь.

При возникновении конфликта при слиянии веток команда git status  покажет какие файлы не прошли слияние после возникновения конфликта (конфликт возникает при наличии более поздних изменений в файле, чем которые вносятся слиянием).

6. git merge --abort - выполняется отмена слияния веток в случае, если конфликт решен, но изменения еще не зафиксированы в последнем коммите.

7. git branch - покажет последние коммиты, выполненные на каждой ветке.

8. git branch --no-merged - покажет только те ветки, которые еще не сливались с main.

9. git log main..branch_name - покажет все коммиты из ветки branch_name, отсутствующие на ветке main.


### **Работа с удаленным репозиторием:**

1. git clone https://github.com/ellandry/project1.git project1 - клонирование удаленного репозитория с GitHub на свой компьютер в новую папку project1.

2. git remote -v - проверим установленную связь с удаленным репозиторием

3. Если требуется свой репозиторий залить на GitHub:

git remote add origin https://github.com/ellandry/project2.git - установка связи с предварительно созанным пустым репозиторием на GitHub;

git branch -M main - укажет основную ветку;

git push -u origin main - отправит в удаленный репозиторий содержимое локального репозитория (ветку main).

4. Если внесли изменения в удаленном репозитории, необходимо загрузить себе актуальную версию:

git pull - сделает  синхронизацию с удаленным репозиторием, в т.ч. merge, т.е слияние

При этом команда git log покажет в истории изменений разных авторов коммитов.

5. git push -u origin branch_name - отправит в удаленный репозиторий содержимое ветки branch_name локального репозитория и создаст ее, если там такой ветки не было.

6. git log origin/main..HEAD (или короче git log origin/main..) - покажет все коммиты из текущей ветки (HEAD), отсутствующие на ветке main на сервере origin (т.е. покажет то, что вы собираетесь отправить в удаленный репозиторий).

