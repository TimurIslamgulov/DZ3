# Что такое контроль версий и зачем он нужен.

**_Контроль версий (контроль исходного кода)_** — практика, которая позволяет отслеживать
изменения исходного кода и управлять ими.

Контроль версий необходим, чтобы:
* Хранение версий сводится к созданию копий информации на компьютере или сервере. 
* Функцию возврата реализуют за счёт восстановления предыдущих версий. 

**Причины осуществления контроля версий**
Приведём две основные причины для осуществления контроля версий, которые на бытовом
уровне кажутся самыми очевидными:
1. Возможность хранить различные версии проекта.
2. Возможность возвращаться к этим версиям.
Соответственно, когда на компьютере мы храним версию нашего прекрасно работающего
сайта, это первый пункт. А когда используем папку с сохранёнными материалами как рабочую,
это считается возможностью возвращаться к различным версиям. Если таких версий много, то
и папок на компьютере также будет много.



Таким образом, **система контроля** — это реализованная возможность замены информации 
с использованием сохраненных версий.
хранить разные версии проекта;
возвращаться к разным версиям проекта.
Примеры: версии сайтов (по датам) и документов.

**Примеры использования контроля версий в жизни:**
* Написание нескольких версий одного текста.
* Сохранение в компьютерных играх.
>Если вы сделали что-то неправильно, вы
всегда можете вернуться к состоянию,
когда вас всё устраивало.
* Группа сотрудников пишет текст в течение
нескольких дней.
>Когда готов первый черновик, его
отправляют на ревью коллеге. Пока он
читает, другие сотрудники продолжают
работу над текстом.
И когда ревьюер «выкатывает» комментарии
к первой версии черновика, у команды уже
появился «Черновик 2». После внесения
правок появляется ещё и «Черновик 3».
Файлы множатся и работа усложняется. 
![схема сохранений файла](картинка_1.png)

# Git - программа для контроля версий

В программировании проблемы совместной
работы над проектами возникли ещё до
появления облачных сервисов.

Программа **Git** берёт на себя контроль версий
проекта и позволяет переключаться между
ними. 

_Обратите внимание: Git хранит не файлы
целиком, а отличия между ними это позволяет экономить память._

_Установка Git и Visual Studio Code_

Начнём с того, как эта система работает на практике. Для этого установите Visual Studio Code и
систему Git, чтобы на своём компьютере повторить всё, что делалось на лекции. Пройдём все
шаги и посмотрим, как это происходит на самом деле.
Чтобы отслеживать изменения, надо где-то наши файлы хранить. Создадим папку на рабочем
столе и назовём её, например, git_education. Название можете выбрать любое, для системы
контроля версий Git оно никакого значения не имеет. Теперь запустим русифицированную
программу Visual Studio Code. Вы можете использовать любую версию, например, привыкать к
английскому языку и не русифицировать её.
Создаём новый файл

Параллельно с контролем версий мы познакомимся с языком разметки Markdown, который
обширно используется в интернете. Вам полезно будет уметь им пользоваться. На самом деле
он очень простой, поэтому не добавит к процессу обучения новой сложности.
Создаём новый файл — он появляется в нашем окошке. Напишем в нём какой-нибудь текст,
например, hello world. Текст может быть любым. Сохраним этот файл, нажав Ctrl+s или Cmd+s,
если работаете на Mac. Теперь попросим Git указать текущий статус. Он говорит нам создать
файлы. Посмотрим, что случилось с Git, после того как мы создали новые файлы.


## Команды Git

Осваивать Git проще в процессе редактирования текстовых файлов.

**Markdown** – язык разметки, который позволяет форматировать текст. Для написания в редакторе **VS Code** используется
синтаксис языка.
Все команды задаём при помощи написания кода в терминале.
Прежде чем создавать репозиторий и инициализировать Git, проверим текущую установленную
версию пограммы. Для этого в терминале введём команду:

Команда **_git --version_**  
* если Git установлен на компьютер, вы увидите его текущую версию.

**Создание Git-репозитория:**
- Берём локальный каталог, который не
находится под версионным контролем, 
и превращаем его в репозиторий.
- Клонируем существующий репозиторий 
из любого места.

Команда **_git init_**  
* Инициализация: указываем папку, в которой
git начнёт отслеживать изменения
* В папке создаётся скрытая папка .git
![Пример с программы](картинка_2.png)

Команда **_git status_**

* Показывает текущее состояние гита, есть 
ли изменения, которые нужно закоммитить (сохранить)

_Чтобы вызвать ранее введённую команду,
пользуемся стрелками на клавиатуре.
Перебираем недавно введённые команды
нажатием стрелки «вверх»._

Команда **_git add_**

- добавляет содержимое рабочего каталога 
в индекс (staging area) для последующего коммита. Эта команда дается после добавления
файлов. Писать название целиком не обязательно: терминал дозаполнит данные автоматически.
![Пример с программы](картинка_3.png)

Команда **_git commit_**

* зафиксировать или сохранить

_По умолчанию **git commit** использует лишь этот индекс, так что вы можете использовать **git add** 
для сборки слепка вашего следующего коммита.
Команда **git commit** берёт все данные, добавленные в индекс с помощью **git add**, и сохраняет их
слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок._
![Пример с программы](картинка_4.png)

Команда **_git log_** 
* Перед переключением версии файла в Git
используйте команду git log, чтобы увидеть
количество сохранений
![Пример с программы](картинка_5.png)

Команда **_git checkout_**

* Переключение между версиями.
Для работы нужно указать не только
интересующий вас коммит, но и вернуться 
в тот, где работаем, при помощи команды 
git checkout master

Команда **_git diff_**

* Показывает разницу между текущим файлом
и сохранённым.
* Перед переключением версии файла в Git
используйте команду git log, чтобы увидеть
количество сохранений.
![Пример с программы](картинка_6.png)

Особенности Markdown

Изучим особенности Markdown. Например, как, применяя специальные символы,
редактировать и форматировать текст. Параллельно будем сохранять произведённые
изменения.
Для начала разберём самое простое действие. Например, выделение текста курсивом. Если
бы мы делали это в какой-нибудь программе типа MS Word или в другом редакторе, то
выделили текст мышкой и нажали соответствующую кнопку или сочетание клавиш. При
работе с Markdown всё выглядит несколько иначе, но не менее просто.
Добавим какое-нибудь новое слово, например, «курсив», и поставим точку. Чтобы это слово
было написано курсивом, надо слева и справа от этого слова поставить звёздочку. Неважно,
где стоят звёздочки — до точки или после. Всё зависит от того, какой блок текста хотите
выделить курсивом. Обратите внимание, что в левой части экрана около слова «курсив» стоят
звёздочки, а в правой — никаких звёздочек уже нет, слово просто написано курсивом.
Итак, сохраним текущую версию и оставим заметку, что в этой версии добавлено выделение
курсивом. Посмотрим, как теперь сохранить текущую версию файла.
Обратите внимание, что после всех изменений я всегда нажимаю Cmd+S или Ctrl+S. Это
необходимо, чтобы изменения сохранились, записались в файл, который, кстати, назван с
ошибкой. Следующим коммитом переименуем его.
Чтобы сохранить эти изменения, надо совершить несколько действий, которые мы уже
делали.
20
1. Первым действием в сохранение добавим файл. Пишем git add и после этого
указываем тот файл, который требуется сохранить. Указываем, например, hello world,
нажимаем Enter. Никаких сообщений об ошибках нет.
2. Теперь создадим commit для сохранения текущего статуса и добавим ему некоторое
сообщение. Например, «Добавили выделение курсивом».
3. Нажимаем Enter.
Вышло сообщение об опечатке — commit написан с двумя буквами o, это не команда Git.
Ничего страшного, вводим команду заново. Просто нажимаем стрелочку «вверх» и смотрим
то, что я ввёл. Исправляем опечатку и нажимаем Enter. В результате всё прошло успешно. У
нас появился новый commit о выделении курсивом.
Переименуем наш файл и посмотрим, что при этом произойдёт внутри системы контроля
версий. Мы можем нажать правую кнопку, переименовать и исправить получившуюся
опечатку. Назовём правильно — hello world. Посмотрим на текущий статус Git после того, как
переименовали файл.
