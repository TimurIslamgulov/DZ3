# **Что такое Git и GitHub?**

**Git** — это система управления версиями, которая пришлась по душе практически всем — от разработчиков до дизайнеров. **GitHub** можно считать соцсетью для хранения кода. Это настоящая Мекка для технарей. Здесь вы можете попрактиковаться в разработке и придумать что-то свое, найти множество open-source проектов, передовых технологий, различных функций и дизайнов.

На GitHub вы учитесь и участвуете в других проектах, храните код для работы или учебы, берете код других проектов и вникаете во все детали. А еще вы можете создавать сайты **бесплатно** напрямую из репозитория! ([Научиться можно здесь](https://nuancesprog.ru/p/4318/))

![](1.jpeg)

Если вы хотите работать на GitHub, то вовсе не обязательно быть гуру в программировании, ведь все самое основное делается прямо на сайте.

Не лишним будет разобраться с терминалом, поскольку терминальные команды действительно упрощают жизнь.

*Если в статье вы видите команду с угловыми скобками: < > , то смело удаляйте эти скобки и меняйте их содержимое на нужный вам текст.*

*Пример: git add <имя\_файла>. Здесь вы можете написать нечто подобное: git add hello\_world.py . Это означает, что вы хотите добавить в репозиторий файл под названием hello\_world.py.*

```
Для начала необходимо запомнить 
следующие терминальные команды: 
```

>git clone

>git status

>git add

>git commit -m “ “

>git push

``` 
Затем к ним добавим еще вот эти: 
```

>git init

>git branch

>git merge

>git checkout

Эти команды вам пригодятся в случае, если вы будете работать с другими людьми или захотите внести какие-то изменения в проект и протестировать их до создания коммита.

``` 
Не лишней будет и вот такая 
команда:
```

>git help

О ней мы также поговорим ниже.

![](2.jpeg)

```
Если вы работаете на Mac, то у вас уже установлен
терминал. Нажмите на иконку с лупой в верхнем
правом углу экрана и напечатайте слово terminal.
```

### **Шаг 1: Регистрация и установка**

Зайдите на [GitHub](https://github.com/?source=post_page---------------------------) и создайте свой аккаунт. В принципе, этим можно и ограничиться. При желании можете [установить Git](https://git-scm.com/downloads?source=post_page---------------------------). Но для работы с GitHub это вовсе не обязательно. Однако если вы планируете заниматься проектами на локальном компьютере, то установка вам все-таки нужна. Можете скачать установщик или [установить файлы через менеджер пакетов](https://gist.github.com/derhuerst/1b15ff4652a867391f03?source=post_page---------------------------).

Теперь перейдите в терминал, и начнем работу. Если хотите задать одно имя пользователя для **всех репозиториев** на компьютере, то напишите:

>git config — global user.name “<ваше\_имя>”

замените <ваше\_имя> на свое имя в кавычках. Можете написать все, что угодно. Если хотите задать имя только для одного репозитория, то удалите из команды слово global.

Теперь напишите свой адрес электронной почты. Проследите, чтобы он совпадал с адресом, указанным при регистрации на GitHub.

>git config — global user.email “<[адрес_почты@email.com](mailto:%D0%B0%D0%B4%D1%80%D0%B5%D1%81_%D0%BF%D0%BE%D1%87%D1%82%D1%8B@email.com)>”

При желании можете скрыть свой электронный адрес. Это сделать несложно, подробнее написано [здесь](https://help.github.com/en/articles/blocking-command-line-pushes-that-expose-your-personal-email-address?source=post_page---------------------------). По сути, вам нужно проставить 2 галочки в своем GitHub-аккаунте.

#### **Теперь вы готовы к работе с Git на локальном компьютере.**

Начнем с создания нового репозитория на сайте GitHub. Вы также можете выполнить git init и создать новый репозиторий из директории проекта.

Репозиторий состоит из трех «деревьев». Первое «дерево» — это **рабочая директория,** в которой хранятся актуальные файлы. Второе — это **index** или область подготовленных файлов. А еще есть **head** — указатель на ваш последний коммит.

#### **Вариант 1. Я уже знаком с терминалом**

Вот как начать работу с Git из терминала.

Если у вас есть директория проекта, то просто перейдите в терминал, а в самой директории проекта выполните команду

>git init

Если хотите инициализировать проект со всеми файлами из директории проекта, то выполните команду

>git init

Допустим, в вашем проекте есть папка new\_project. Вы можете перейти в нее из окна терминала и добавить локальный репозиторий. Это делается через следующую команду:

>cd new\_project

>git init

В вашем проекте появилась новая скрытая директория с названием.git. Именно здесь Git хранит все, что ему нужно для отслеживания проекта. Теперь вы можете последовательно добавлять файлы в область подготовки:

>git add <имя\_первого\_файла>

или добавьте сразу все файлы через:

>git add .

Создать коммит с этими изменениями можно через команду:

>git commit -m “<сообщение\_коммита>”

Если изменения вас устраивают, напишите:

>git push

и отправьте эти изменения в репозиторий. Проверить, есть ли изменения для отправки, можно в любое время по команде:

>git status

При внесении изменений следует обновить и сами файлы:

>git add <имя\_файла>

или

>git add — all

Создайте коммит, добавьте нужное сообщение и отправьте этот коммит в репозиторий.

```
Вот и все! 
Теперь вы можете инициализировать репозиторий,
создавать коммиты с файлами и сообщениями,
а также отправлять коммиты в ветку master.
```

![](3.jpeg)

 #### **Вариант 2. Я вообще ничего не знаю** 

Этот вариант выбирают совсем новички в разработке. Вполне возможно, у вас уже есть целая папка с файлами проекта для размещения на GitHub, но вы не знаете, с чего начать.

Ну что ж, приступим к делу!

Допустим, вы хотите создать новый репозиторий. Это место, где будет «жить » ваш проект. Если вы не хотите создавать новый репозиторий, то можете склонировать уже существующий. Именно так вы копируете чужой проект или берете нужную вам информацию для работы/учебы. Мы еще к этому вернемся, но чуть позже.

**Репозиторий** — это место, в котором вы систематизируете свой проект. Здесь вы храните файлы, папки, видео, изображения, блокноты Jupyter Notebook, наборы данных и т.д. Перед началом работы с Git необходимо инициализировать репозиторий для проекта и правильно его подготовить. Это можно сделать на сайте GitHub.

```
Лучше сразу добавлять в репозиторий 
**README**-файл с информацией о проекте.
Это можно сделать в момент создания репозитория,
поставив галочку в соответствующем поле.
 ```

И так:
- Перейдите на сайт GitHub. Нажмите на значок **+** в верхнем правом углу, а затем выберите **New repository**.
- Придумайте имя репозитория и добавьте короткое описание.
- Решите, будет ли этот репозиторий размещаться в открытом доступе или останется закрытым для просмотра.
- Нажмите **Initialize this repository with a README** для добавления README-файла. Настоятельно рекомендую снабжать все ваши проекты файлом-описанием, ведь README — это первая вещь, на которую люди обращают внимание при просмотре репозитория. К тому же, здесь можно разместить нужную информацию для понимания или запуска проекта.

###### <center> Новый репозиторий </center>
![](4.png)
###### <center> Создание нового репозитория </center>
![](5.png)

При желании можете уже сейчас начинать работать над проектом. Добавляйте файлы, вносите в них изменения и т.д. напрямую с сайта GitHub. Однако конечный результат подобной деятельности может вас немного огорчить.

Вносить изменения в проект можно двумя способами. Вы можете изменять файлы/блокноты на компьютере либо делать это на сайте GitHub.

```
Допустим, вам захотелось подкорректировать
README-файл на сайте GitHub.
```

- Для начала перейдите в ваш репозиторий.
- Для выбора файла кликните по его названию (например, кликните по **README.md** для перехода к файлу-описанию).
- В верхнем правом углу вы увидите иконку с карандашом. Нажмите на нее для внесения изменений.
- Напишите короткое сообщение, передающее суть изменений (и подробное описание, если сочтете это нужным).
- Нажмите кнопку **Commit changes**.

###### <center> Изменение файла на GitHub </center>
![](6.png)

###### <center> Подготовка коммита с изменениями </center>
![](7.png)

Вы успешно внесли изменения в README-файл своего нового репозитория! Обратите внимание на небольшую кнопку на картинке выше. Она позволяет создавать новую ветку этого коммита и добавлять Pull request. Запомните ее, скоро к ней вернемся.

```
Как вы видите — ничего сложного!
```

#### **Подайте мне вот этот проект!**

Возможно, вы захотите клонировать свой новый репозиторий для дальнейшей работы с ним на локальном компьютере. Либо у вас уже есть существующий репозиторий, который вы хотели бы клонировать.

Для **клонирования репозитория** на компьютер перейдите в репозиторий на GitHub и нажмите большую зеленую кнопку под названием **Clone or download** (разумеется, вы можете просто скачать репозиторий и избежать всех заморочек с терминалом. Но я в вас верю, поэтому не будем сдаваться!). Проследите, чтобы появилась надпись **Clone with HTTPS**. Теперь нажмите на иконку буфера обмена для копирования-вставки (либо выделите ссылку и скопируйте ее).

###### <center> Клонирование или скачивание репозитория </center>
![](8.png)

Откройте **терминал** и перейдите в директорию для копирования репозитория. Например, для перехода на **Рабочий стол** напечатайте вот это:

>cd Desktop

Затем клонируйте туда репозиторий по следующей команде:

>git clone <то,\_что\_вы\_только\_что\_скопировали>

Все просто! Не забудьте изменить информацию в угловых скобках на нужную вам. И удалите сами скобки < >.

*Если вы не очень хорошо ориентируетесь в терминале, то переход по директориям можно осуществлять через команду cd. Например, откройте терминал и напечатайте ls для отображения перечня доступных директорий. Вполне возможно, что в этом списке вы сразу увидите директорию Desktop. Либо напечатайте cd Desktop. Далее выполните команду git clone и склонируйте репозиторий на Рабочий стол.*

*Бывает и так, что вместо перечня расположений, вы видите различные имена пользователей. Тогда до того, как перейти в Desktop, вам потребуется выбрать нужного пользователя через команду cd <пользователь> (замените <пользователь> на нужное вам имя). Затем снова напечатайте ls, чтобы увидеть весь список. И вот теперь, увидев в списке Desktop, смело печатайте cd Desktop. Сейчас уже можно выполнять git clone!*

*Если вдруг в терминале вы захотите «откатиться» на шаг назад, то напишите cd ..*

Новый GitHub-репозиторий, склонированный на рабочий стол, готов! Данная команда создает точную копию репозитория в вашей системе. Здесь вы сможете с ним работать, редактировать, индексировать изменения, создавать коммиты с изменениями и отправлять их на GitHub.

*Совсем не обязательно создавать репозиторий на Рабочем столе. Клонировать можно в любое место на компьютере. Команду git clone можно выполнять и сразу после открытия терминала. Однако, если вы не очень любите копаться в папках на компьютере, то неплохо будет разместить проект на виду, то есть на Рабочем столе…*

Если хотите просто покопаться в каком-то проекте, то вместо клонирования можете сделать **форк** проекта на GitHub. Для этого нажмите кнопку **Fork** в верхнем правом углу сайта. Так вы добавите копию этого проекта в свои репозитории и сможете вносить туда любые изменения без вреда для оригинала.

##### **Добавляем файлы в проект**
___
![](9.jpeg)

Вот, чем мы займемся:

>git status

>git add

>git commit -m “ “

>git push

Но ничего сложного здесь нет!

Должно быть, у вас уже есть файлы, которые вы бы хотели разместить в новом репозитории. Отыщите их на компьютере и перетащите в новую папку репозитория на Рабочем столе.

Проверьте **статус** проекта.

Откройте терминал и перейдите в папку репозитория. Для проверки обновлений выполните:

>git status

Если вы перетаскивали файлы в папку проекта, то потребуется обновить состояние репозитория. Добавлять файлы в репозиторий можно по одному:

>git add <имя\_файла>

Либо все сразу:

>git add — all

или даже:

>git add .

Это ваши предлагаемые изменения. Операцию можно повторить с новыми файлами либо с уже существующими, но измененными. По сути, ничего нового в сам проект вы не добавляете. Вы всего лишь загружаете новые файлы и указываете Git на эти изменения.

Процесс создания коммитов с изменениями начинается с выполнения команды:

>git commit -m “<сообщение\_о\_коммите>”

Коммиты изменений добавляются в **head** (указатель), а не в удаленный репозиторий. Не забудьте заменить текст в скобках и убрать <>. После внесения изменений создается снимок состояния репозитория, для чего используется командаcommit. А через –m добавляется сообщение об этом снимке.

Сохраненные изменения и называются коммитом. При создании коммита вы добавляете сообщение о том, что именно менялось и почему. Так другие люди смогут лучше понять суть изменений.

Теперь ваши изменения сохранены в указателе локальной копии проекта. Для отправки изменений на удаленный репозиторий выполните команду:

>git push

Актуальность версии можно проверить в любое время через команду:

 >git status

 ```
 Итог: у вас есть свой GitHub репозиторий, 
 вы научились добавлять и изменять в нем файлы.
 ```

 ### **Шаг 2: Работа с удалёнными репозиториями**

 Чтобы иметь возможность совместной работы над каким-либо Git-проектом, необходимо знать как управлять удалёнными репозиториями. Удалённые репозитории — это модификации проекта, которые хранятся в интернете или ещё где-то в сети. Их может быть несколько, каждый из которых как правило доступен для вас либо только на чтение, либо на чтение и запись. Совместная работа включает в себя управление удалёнными репозиториями и помещение (*push*) и получение (*pull*) данных в и из них тогда, когда нужно обменяться результатами работы. Управление удалёнными репозиториями включает умение добавлять удалённые репозитории, удалять те из них, которые больше не действуют, умение управлять различными удалёнными ветками и определять их как ослеживаемые (*tracked*) или нет и прочее. Данный раздел охватывает все перечисленные навыки по управлению удалёнными репозиториями. 

 #### **Отображение удалённых репозиториев**

 Чтобы просмотреть какие удалённые серверы у вас уже настроены, следует выполнить команду:
 
 >git remote
 
 Она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов. 
 Если вы склонировали ваш репозиторий, у вас должен отобразиться по крайней мере **origin** — это имя по умолчанию, которое Git присваивает серверу.

 Чтобы посмотреть какому URL соответствует сокращённое именя в Git, можно указать команде опцию *-v* :

>git remote -v

```
origin  https://github.com/user/***.git (fetch)
origin  https://github.com/user/***.git (push) 
```

Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:

>cd <путь_к_репозиторию_на_ПК>

>git remote -v 

```
bakkdoor  https://github.com/bakkdoor/***.git (fetch)
bakkdoor  https://github.com/bakkdoor/***.git (push)
cho45     https://github.com/cho45/***.git (fetch)
cho45     https://github.com/cho45/***.git (push)
defunkt   https://github.com/defunkt/***.git (fetch)
defunkt   https://github.com/defunkt/***.git (push)
koke      git://github.com/koke/***.git (fetch)
koke      git://github.com/koke/***.git (push)
origin    git@github.com:user/***.git (fetch)
origin    git@github.com:user/***.git (push)
```
Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

Обратите внимание на разнообразие протоколов, используемых при указании адреса удалённого репозитория, подробнее с этим познакомиться можно изучив установку Git на сервер.

#### **Добавление удалённых репозиториев**

В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (*shortname*), просто выполните команду:

>git remote add <имя> <путь>
```
git remote add pb https://github.com/paulboone/***.git
```
проверим:
>git remote -v
```
origin	https://github.com/user/***.git (fetch)
origin	https://github.com/user/***.git (push)
pb	https://github.com/paulboone/***.git (fetch)
pb	https://github.com/paulboone/***.git (push)
```
Теперь вместо указания полного пути вы можете использовать *pb*. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду:
>git fetch pb
```
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/***.git
 * [new branch]      master     -> pb/master
 * [new branch]       ***       -> pb/***
 ```
Ветка **master** из репозитория Пола сейчас доступна вам под именем *pb/master*. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола.

![](10.jpeg)

#### **Получение изменений из удалённого репозитория — Fetch и Pull**

Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

>git fetch <имя>

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда *clone* автоматически добавляет этот удалённый репозиторий под именем «*origin*». 
Таким образом, *git fetch origin* извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью *fetch*).
```
Важно отметить, что команда:
```
>git fetch

```
забирает данные в ваш локальный репозиторий,
но не сливает их с какими-либо вашими наработками
и не модифицирует то, над чем вы работаете 
в данный момент. 
Вам необходимо вручную слить эти данные
с вашими, когда вы будете готовы.
```

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду:

>git pull

чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда:

>git clone

автоматически настраивает вашу локальную ветку **master** на отслеживание удалённой ветки **master** на сервере, с которого вы клонировали репозиторий. 
Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение *git pull*, как правило, извлекает (*fetch*) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (*merge*) их с кодом, над которым вы в данный момент работаете.

***Примечание***

```
Начиная с версии 2.27, команда git pull выдаёт предупреждение, 
если настройка pull.rebase не установлена.
Git будет выводить это предупреждение каждый раз
пока настройка не будет установлена.
```
Если хотите использовать поведение Git по умолчанию (простое смещение вперёд если возможно — иначе создание коммита слияния): 

>git config --global pull.rebase "false"

Если хотите использовать перебазирование при получении изменений: 

>git config --global pull.rebase "true"

#### **Отправка изменений в удаленный репозиторий (Push)**

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: 

>git push <имя> <имя_ветки>

Чтобы отправить вашу ветку **master** на сервер **origin** (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

>git push origin master

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду *push*. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду *push*, а после него выполнить команду *push* попытаетесь вы, то ваш *push* точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить *push*. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

#### **Просмотр удаленного репозитория**

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду:

>git remote show <remote>

выполнив эту команду с некоторым именем, например, origin, вы получите следующий результат:

```
* remote origin
  Fetch URL: https://github.com/user/***.git
  Push  URL: https://github.com/user/***.git
  HEAD branch: main
  Remote branches:
    br_1                         tracked
    br_2                         tracked
    br_6                         tracked
    main                         tracked
    refs/remotes/origin/br_3     stale (use 'git remote prune' to remove)
    refs/remotes/origin/br_4     stale (use 'git remote prune' to remove)
    refs/remotes/origin/br_5     stale (use 'git remote prune' to remove)    
  Local branches configured for 'git pull':
    br_1     merges with remote br_1
    br_2     merges with remote br_2
    br_3     merges with remote br_3
    br_4     merges with remote br_4
    br_5     merges with remote br_5
    br_6     merges with remote br_6
    main     merges with remote main
  Local refs configured for 'git push':
    br_1 pushes to br_1 (up to date)
    br_2 pushes to br_2 (up to date)
    br_6 pushes to br_6 (up to date)
    main pushes to main (fast-forwardable)
```
Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке **main**, выполните *git pull*, ветка **main** с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Это был пример для простой ситуации и вы наверняка встречались с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от *git remote show*:

```
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
  Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)
```
Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении *git push*.
Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении *git pull*.

#### **Удаление и переименование удалённых репозиториев**

Для переименования удалённого репозитория можно выполнить:

>git remote rename

Например, если вы хотите переименовать *pb* в *paul*, вы можете это сделать:

```
> git remote rename pb paul
> git remote

origin
paul

Стоит упомянуть, что это также изменит
имена удалённых веток в вашем репозитории.
То, к чему вы обращались как pb/master,
теперь стало paul/master.
```

Если по какой-то причине вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать:

>git remote remove <имя>

```
> git remote remove paul
> git remote

origin
```
При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.