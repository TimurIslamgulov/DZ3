# Инструкция по работе с командами Git, используя возможности Markdown

## git init
Команда __*git init*__ - инициация файла, создание репозитория Git. 
Запускаем команду в первую очередь.

## git add <file_name>
Команда __*git add <file_name>*__ - команда для подготовки файла (внесенных изменений) к коммиту (фиксации изменений, сохранения), где вместо <file_name> указывается название файла, включая его расширение. Можно использовать клавшу __Tab__ и программа автоматически будет подставлять верное название файла. 
Например, в нашем случае: *git add .\Practice1.md*

## git commit -m
Команда __*git commit -m "Комментарий"*__ - команда для фиксации изменений с добавлением комментариев в кавычках (" ").
Например, после заполнения данной строки, после прописания команды *git add*, введем команду фиксации изменений со следующим комментарием: *git commit -m "Дополнили пояснения к командам init, add и commit"*

## Теперь введем следующую команду для проверки статуса файлов в репозитории: __*git status*__, получим следующие виды:

**1. В файле:** ![Cкрин-окна редактора](/DZ3/Redactor%20view.jpg)

**2. В терминале:** ![Скрин-статуса](/DZ3/Git%20status%20(with%20no%20commit).jpg)

В терминале выделено красным **_modified: Practice1.md_** - что означает, что в наш файл были внесены изменения.

После внесения каждого изменения следует закоммитить (зафиксировать изменения), используя следующие команды:
* __*git add*__ и _**git commit -m**_,
или
* __*git commit -am*__ - добавили букву _**"а"**_ перед буквой _**"m"**_ - это объединенная команда подготовки и фиксации изменений (здесь также команда продолжается комментарием в кавычках)

Также не стоит забывать про фиксацию изменений - сделанных добавлением картинок. Их также следует сначала добавить в папку репозиторий, использую команду *__git add__* и выбрать соответствующую картинку, и следом зафиксировать командой __*git commit -m*__

## После внесенных изменений, следует обратить внимание на возникающий вопрос по проверке всех внесенных изменений. Здесь нам поможет команда *__git log__*
>_**git log** перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита._

С разными опциями команды _**git log**_ можно ознакомиться по этой [ссылке - Основы Git](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2)

## Чтобы увидеть, что мы изменили, но пока не закоммитили, следует набрать команду __*git diff*__
### Мы увидим следующие данные в терминале:
![Скрин-терминала](/DZ3/Terminal%20-%20git%20diff.jpg)
Зеленым цветом выделено то, что мы добавили

__*Для преподавателя - *__ *небольшое примечание и вопрос: не много не понял, что подразумевается под выделением красным цветом, это просто новые строки?*

Следует закоммитить (зафиксировать) все изменения и проверить командой *__git log__* все изменения:
![Git log](/DZ3/Git%20log.jpg)

## После добавления данной инструкции и ее фиксации с помощью команды *__git commit -am"__*, следует проверить текущий статус (команда *__git status__*)
У нас образовались 4 Untracked files (неотслеживаемых файла, неиндексированных), а именно - картинки для вставки Git - выделены красным ![Terminal screen](/DZ3/Terminal%20screen.jpg)

Используя команду "*__git add .__*" мы можем сразу заиндексировать в отслеживание все неотслеживаемые файлы. Набираем команду в терминале и коммитим.

## Следующая связка команд для изучения - команды связанные с ветками - branch
## Команда *__git branch__*
Показывает в терминале какие ветки существуют, и звездочка (*), слева от названия ветки, указывает на какой именно ветке мы находимся.

В нащем случае у нас есть 2 ветки:
1. DZ3_Sanzhar
2. main

Звездочка находится на ветке DZ3_Sanzhar ![Git_branch](/DZ3/Git_branch.jpeg)

## Чтобы переключиться с ветки на ветку, используем комманду *__git checkout branch_name__* (вместо branch_name указывается название ветки, в которую хотим перейти)
# Эта же команда используется для перехода между коммитами, только вместо branch_name указывается первые 4-6 символов названия (индекса) коммита, обычно выделено желтым. 
В картинке ниже видно commit bb2f103407a6ab5cc6eece85b4b10a809b3561eb ![Git_commit](/DZ3/Git_commit.jpeg)

Если прописать команду *__git commit bb2f10__* мы вернемся на статус файлов сделанных после фиксации данного коммита, и все изменения, сделанные позже, исчезнут. 

Создадим дополнительную ветку и назовем ее Test
## Команда *__git branch Test__*
Переходим на нее, вносим изменения в файле, делаем индексирование (подготовку в фиксации) и фиксируем все изменения (коммитим).


## Начиная с 50-й строки у нас пошли изменения в файле, и они были зафиксированы в новой ветке Test. Сейчас сделаем слияние - команда *__git merge branch name__* (использование следующее: находясь в первой ветке производим слияние второй ветки в первую, как пример, мы находимся в ветке *DZ3_Sanzhar* и чтобы слить в нее изменения с ветки *Test* набираем команду *__git merge Test__*, и коммитим это)

После слияния, мы увидим следующую картинку ![Git_merge](/DZ3/Git_merge.jpeg)
Зеленым выделены те изменения, которые у нас в основной ветке DZ3_Sanzhar.
Синим выделены те изменения, которые мы соединяем из ветки Test.
Справа снизу видна кнопка "Resolve in Merge Editor"
Пройдя по ней мы сможем выбрать тот вариант "слияния" изменений, который нам необходим:
* Оставить и принять изменения, которые есть в основной ветке и автоматический коммит;
* Оставить и принять изменения, которые есть во второй ветке и автоматический коммит;
* Оставить и принять изменения из обеих веток и автоматический коммит;
* Удалить и не принимать изменения и автоматический коммит.

## Коммитим все!

# И так как, основная ветка - это не __*DZ3_Sanzhar*__, а *__main__*, и основаная ветка является "форкнутой" с GitHub'а, мы уже выполнили следующие команды:
1. Мы сделали _**Fork**_ репозитория - [Домашка №3 от Тимура](https://github.com/TimurIslamgulov/DZ3), пройдя по ссылке, и зарегистрировавшись на GitHub'е, нажали кнопку **_"Fork"_** (стащили репозиторий к себе в профиль);
2. После, уже в "своих" репозиториях мы скопировали ссылку "форкнутого репозитория Тимура";
3. Создали папку **"Practice 3"** у себя на компьютере;
3. Запустили VSCode и открыли папку;
4. В терминале прописали команду - **_"git clone https://github.com/SanzharDos/DZ3.git"_** команда _**git clone**_ клонирует репозиторий по ссылке в нашу папку на компьютере;
5. У нас запустился репозиторий Тимура;
6. Мы создали ветку **_"DZ3_Sanzhar"_** и вносили все изменения в ней;
7. Чтобы отправить изменения в наш репозиторий на GitHub'е нужно прописать команду __*git push --set-upstream origin*__. Этой командой мы свяжем наш репозиторий на ПК и наш же репозиторий на сайте GitHub (в случае ошибок Git сам поможет и подскажет что мы делаем не так, нам также нужно будет пройти авторизацию, Git здесь тоже поможет,); 
8. После заходим в наш репозиторий на GitHub'е и у нас появится кнопка __*"Pull request"*__. Пройдя по ней - мы направим Тимуру наш измененный репозиторий.

## Коммитим все, и переходим к задаче :)

Блок-схема - [ссылка для скачивания](https://drive.google.com/file/d/1EqUR2IQ9rF4p9gBQxJRJU4MYGhZn7zse/view?usp=share_link) и сама картинка![Блок-схема](/DZ3/Algoritm.jpg)
