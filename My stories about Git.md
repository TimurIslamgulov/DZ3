# **Всем привет!**

## *Меня зовут Цапенко Денис Сергеевич.*

<img src="shrine.jpg" width="250"/>

Я прохожу обучение в онлайн школе по IT образованию - **GeekBrains**, и хочу Вам расказать немного про **Git** с использованием синтаксиса **Markdown**.

## ***Начнем с основ....***

>Итак, ***Git*** — *это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах. Чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус.* 

## ***Для чего он нужен?*** 

>1. С помощью него мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать.
>2. Он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом.

### Изучим следующие команды...

* **git init** - инициализация репозитория
* **git status** - показать текущий статус проекта
* **git add** - добавление файлов в состояние staged
* **git commit -m "Сообщение(message)"** - создает коментарий к сохранению изменения в файле.
* **git checkout** - используется для перемещения, между коммитами, версиями отдельных файлов и ветками.
* **git log** - получить историю коммитов в репозитории

### В Git очень просто форматировать текст.

К примеру, уровень заголовка формируется слудующим образом. У нас максимум 6 уровней заголовка.
* # Заголовок первого уровня - "#"
* ## Заголовок второго уровня - "##"
* ### Заголовок третьего уровня - "###"
* #### Заголовок четвертого уровня - "####"
* ##### Заголовок пятого уровня - "#####"
* ###### Заголовок шестого уровня - "######"

Форматирование самого текста делается следующим образом...

* Для написания текста *Курсивом*, необходимо текст поместить между символами (*) с дувух сторон выделяемого текста, или нижнинего подчеркивания (_) - _Пример_.
* Для выделения текста **полужирным**, необходимо текст поместить между символами (**) с дувух сторон выделяемого текста, или нижнинего подчеркивания (__) - __Пример__.

Альтернативные способы выделения текста жирным или курсивом нужны для того, чтобы мы могли совмещать оба этих способа. 

Например: **Текст может быть выделен курсивом и при этом быть __полужирным__**.

* Для  написания текстом ***полужирным курсивом***, необходимо текст поместить между символами "***" с дувух сторон выделяемого текста.
* Для написания ~~зачеркнутого текста~~, необходимо текст поместить между символами "~~" с дувух сторон выделяемого текста.
* Для подчеркивания текста необходимо прописать на следующей строке знак "=". Пример:

Подчеркивание текста
=

* Для ненумерованого списка "* и пробел в начале предложения". Например:

* Один 
* Два 
* Три

Так же есть другие символы, такие как "+", "-"

    - Первый пункт

    + Второй пункт
    
    * Третий пункт

Соответственно получится следующее:

- Первый пункт

+ Второй пункт

* Третий пункт

Cпровоцируем конфликт слияний веток

+ Элемент 4

* Для нумерации списков вводим порядковый № с точкой. Например:

    1. Один
    2. Два
    3. Три

* Для написания циатат вначале необходимо написать символ ">"

> С помощью цитат очень удобно в письме обозначать исходный текст.

> Эта строка - часть той же цитаты.

#### Перейдем к написанию таблиц

Для написания таблицы, вертикальные линии "|" обозначают столбцы:

    | Столбец 1 | Столбец 2 | Столбец 3 |
    | ----------|:---------:| ---------:|
    | Строка 1  |           |           |
    | Строка 2  |           |           |
    | Строка 3  |           |           |

Внешние вертикальные линии (|) не обязательны, и они нужны только чтобы сам код Markdown выглядел красиво.

*На этом мое краткое руководство по Git окончено. Я старался изложить вводную информацию как можно более доступно. Git довольно сложен, и в нем есть еще много функций и трюков для изучения.*

## *Всем спасибо за внимание!!!*

# Урок 2. Дополнение к инструкции по Git с использованием синтаксиса Markdown

## Параграфы и разрывы строк
---

Для того, чтобы создать параграф с использованием синтаксиса языка Markdown, достаточно отделить строки текста одной (или более) пустой строкой (пустой считается всякая строка, которая не содержит в себе ничего, кроме пробелов и символов табуляции). 

Для того, чтобы вставить видимый перенос строки (элемент <br/>) необходимо окончить строку двумя пробелами и нажатием клавиши «Enter». Многие элементы синтаксиса Markdown выглядят и работают гораздо лучше в случае, когда их форматируют с помощью «жесткого перевода строк» (разделение строк, осуществленное самим пользователем, а не программой автоматически).

## Цитаты

Вложение цитаты в цитату выглядит следующим образом:

<br> > Первый уровень цитирования
<br> >> Второй уровень цитирования
<br> >>> Третий уровень цитирования
<br> >
<br> > Первый уровень цитирования</br>

В результате на экран выводится следующее:

> Первый уровень цитирования
>> Второй уровень цитирования
>>> Третий уровень цитирования
> 
> 
> Первый уровень цитирования

#### *Уровень цитирования не может превышать 15.*

## Горизонтальные линии (разделители)

Для того чтобы создать горизонтальную линию с использованием синтаксиса языка Markdown, необходимо поместить три (или более)дефиса или звездочки на отдельной строке текста. Между ними возможно располагать пробелы. Горизонтальные линии в Markdown выглядят следующим образом:

"Первая часть текста, который необходимо разделить

"***"

Вторая часть текста, который необходимо разделить"

Или

"Первая часть текста, который необходимо разделить

"---"

Вторая часть текста, который необходимо разделить

В результате на экран выводится следующее:

Первая часть текста, который необходимо разделить

--- 

Вторая часть текста, который необходимо разделить

При использовании данного инструмента важно помнить, что после первой части текста и перед второй необходимо оставлять пустую строку. Данное правило необходимо соблюдать только при использовании дефисов. Если его не соблюдать, на экран будет выведен заголовок второго уровня и строка обычного текста. При использовании символа звездочки данным правилом можно пренебречь.

## Дополнительные элементы

Может употребляться в **Markdown** перед специальными символами для того, чтобы они воспринимались в их буквальном (а не служебном) значении. Полный список данных символов приводится ниже:

«\»  - слеш;  

«`»  - обратный апостроф;  

«*»  - звездочка;  

«_»  - символ подчеркивания;  

«{}»  - фигурные скобки;  

«[]»  - квадратные скобки;  

«()»  - круглые скобки;  

«#»  - символ решетки;  

«+»  - плюс;  

«-»  - минус (дефис);  

«.»  – точка;  

«!»  - восклицательный знак.  

## Автоматические ссылки

Markdown поддерживает упрощённый порядок автоматического создания ссылок для URL-адресов и адресов электронной почты. Для этого достаточно поместить URL-адрес или почтовый адрес в угловые скобки, и Markdown сделает его гиперссылкой. В отличие от вышеописанных стилей, в данном случае сам же URL-адрес или почтовый адрес становится и текстом гиперссылки. Автоматические ссылки на адреса электронной почты работают аналогично.
Автоматические ссылки в языке Markdown выглядят следующим образом

    <http://example.com/>

В результате на экран выводится следующее: <http://example.com/>

Автоматическая ссылка на адрес электронной почты в Markdown выглядит следующим образом

    <address@example.com>

В результате на экран выводится следующее: <address@example.com>  

## Работа с изображениями

Чтобы вставить изображение в текст, достаточно написать следующее.

![Привет, здесь отображена природа!](les.jpg)

![Привет, здесь изображен закат](home.jpg)

# Работа с удаленным репозиторием

## Что такое удаленный репозиторий?

Удаленный репозиторий – это версии проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.
Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

## Добавление удаленного репозитория к существующему локальному.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub.
Будет предложено выбрать одну из трех ссылок: для протоколов https и ssh и для клиента GitHub на компьютер. 

    Вот примеры этих трех ссылок для репозитория geometric_lib известного вам по практическим занятиям этого курса:
    HTTPS-ссылка: https://github.com/Denni90/DZ3.git
    SSH-ссылка: git@github.com:Denni90/DZ3.git
    GitHub CLI ссылка: gh repo clone Denni90/DZ3

Теперь разберемся, в чем отличие. Начнем с последней - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git. Этот клиент можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git.

* В чем разница между первыми двумя?

Дело в том, что существует два основных протокола подключения к git-серверу: HTTPS и SSH. SSH считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них. А окончательный выбор протокола оставим на вкус читателя.

## Клонирование удаленного репозитория. 

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда **git clone**.

В директории, откуда вы запустили команду **git clone**, создается директория с именем репозитория. В нашем случае, если мы выполнили команду из директории пользователя, будет создана папка C:\My_DZ\DZ3\.
В созданную директорию копируется репозиторий, все его ветки и коммиты.
В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем origin и ссылкой, которую мы передавали в **git clone**. Это избавляет нас от необходимости вручную писать ***git remote add origin https://github.com/Denni90/DZ3.git***. На этом процесс клонирования заканчивается.

## Получение изменений из удаленного репозитория

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда **git fetch**.

Давайте рассмотрим пример, чтобы разобраться, что на самом деле делает git fetch. Допустим, у нас есть репозиторий, к которому подключен удаленный репозиторий. Структура рабочих копий и логи выглядят следующим образом:

**Локальный репозиторий**

    ├── alpha.txt
    └── num.txt
    * 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |  (HEAD -> dev, origin/develop)

**Удаленный репозиторий**

    ├── alpha.txt
    ├── new_file.txt
    └── num.txt
    * b9ad22e | 2021-05-10 | New commit | [Smartiqa] |  (HEAD -> develop, origin/develop)
    * 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |

Как видно, в удаленном репозитории есть один коммит, которого нет у нас. В этом коммите был добавлен файл new_file.txt. Кроме того видно, что наша копия удаленной ветки origin/dev находится на первом коммите, хотя должна быть на втором. Чтобы обновить информацию для этой ветки, нам и понадобится git fetch. Выполним команду **git fetch origin**:

    Git Bash
    $ git fetch origin
    remote: Enumerating objects: 4, done.
    remote: Counting objects: 100% (4/4), done.
    remote: Compressing objects: 100% (2/2), done.
    remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
    Unpacking objects: 100% (3/3), 287 bytes | 143.00 KiB/s, done.
    From github.com:smartiqaorg/test-repo
    47573c7..b9ad22e  develop -> origin/develop

В выводе команды видно, что она скачала несколько объектов, а из последней строчки мы узнаем, что ветка develop удаленного репозитория была записана в ветку origin/develop на нашем компьютере.

## Получение изменений из удаленного репозитория

Связкой **git fetch && git merge** мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она **git pull**. Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. 

## Отправка изменений в удаленный репозиторий

Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в __Git__ существует команда **git push**.

По факту данная команда аналогична связке **git fetch + git merge**, но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Команда загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме *fast-forward*, и при этом не был передан ключ *force*, выполнение закончится с ошибкой.

Более подробно разберем, как работает эта команда. Допустим, мы выполнили ***git push origin develop*** в нашем локальном репозитории. 

##### Возможны три варианта развития событий.

Если изменения с нашей ветки можно слить с удаленной веткой в режиме ***fast-forward***, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме ***fast-forward*** выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

Но если вы вдруг передали флаг ***--force***, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага – ***--force-with-lease***. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка.